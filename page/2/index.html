<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="A place for codeing break.">
<meta property="og:type" content="website">
<meta property="og:title" content="Carlmartin&#39; Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Carlmartin&#39; Blog">
<meta property="og:description" content="A place for codeing break.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Carlmartin">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Carlmartin' Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Carlmartin' Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">In me the tiger sniffs the rose.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Carlmartin</p>
  <div class="site-description" itemprop="description">A place for codeing break.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/10/StarRocks%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/10/StarRocks%E5%AD%A6%E4%B9%A0-%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">StarRocks学习: 读写流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-10 14:59:24" itemprop="dateCreated datePublished" datetime="2021-12-10T14:59:24+08:00">2021-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadListener(handleEvent) -&gt;ConnectProcessor(processOnce -&gt;dispatch-&gt;handleQuery) -&gt; StmtExecutor(execute)</span><br><span class="line">StmtExecutor(execute)</span><br><span class="line">    |-&gt; StatementPlanner(plan): Analyzer(analyze) -&gt; createQueryPlan: Optimizer -&gt; PlanFragmentBuilder</span><br><span class="line">    |-&gt; handleQueryStmt : Coordinator(<span class="built_in">exec</span>) -&gt; Coordinator(getNext) -&gt; MysqlChannel(sendOnePacket)</span><br><span class="line">Coordinator(<span class="built_in">exec</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olap_scan_node -&gt; tabel_scanner -&gt; tablet_reader(_init_collector) -&gt; BetaRowset(get_segment_iterators) -&gt; SegmentIterator</span><br></pre></td></tr></table></figure>
<h3 id="Rowset-package"><a href="#Rowset-package" class="headerlink" title="Rowset package"></a>Rowset package</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SegmentIterator(do_get_next,_init,_get_row_ranges_by_keys,_init_column_iterators) -&gt; Segment(new_column_iterator) -&gt;ColumnReader-&gt;ColumnIterator</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ColumnIterator &gt;&gt; (DefaultValueColumnIterator|ArrayColumnIterator|DictCodeColumnIterator|ScalarColumnIterator)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Segment::new_iterator &gt;&gt; (SegmentChunkIteratorAdapter | SegmentIterator)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ColumnReader &gt;&gt; (ZoneMapIndexReader|OrdinalIndexReader|BitmapIndexReader|BloomFilterIndexReader) &gt;&gt; IndexedColumnReader &gt;&gt; IndexedColumnIterator &gt;&gt; IndexPageIterator</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageBuilder &gt;&gt; (BinaryDictPageBuilder|BinaryPlainPageBuilder|BinaryPrefixPageBuilder|BitshufflePageBuilder|FrameOfReferencePageBuilder|PlainPageBuilder|RlePageBuilder) &gt;&gt; EncodingInfo &gt;&gt; ColumnReader</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StoragePageDecoder &gt;&gt; PageIO::read_and_decompress_page &gt;&gt; ColumnReader::read_page</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SegmentIterator &gt;&gt; ColumnDecoder.(check_global_dict|encode_to_global_id) </span><br></pre></td></tr></table></figure>
<h3 id="Vectorized-package"><a href="#Vectorized-package" class="headerlink" title="Vectorized package"></a>Vectorized package</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChunkIterator &gt;&gt; (SegmentIterator|SegmentChunkIteratorAdapter|TimedChunkIterator|AggregateIterator|EmptyIterator|MergeIterator|ProjectionIterator|TabletReader|UnionIterator) &gt;&gt; TabletReader</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StorageEngine(_perform_base_compaction) &gt;&gt; (CumulativeCompaction|BaseCompaction)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ColumnPredicate &gt;&gt; (NullPredicate|ColumnEqPredicate|BinaryColumnEqPredicate|ColumnExprPredicate|ColumnTruePredicate|ColumnGePredicate|BinaryColumnGePredicate|ColumnGtPredicate|BinaryColumnGtPredicate....) &gt;&gt; </span><br><span class="line">ColumnPredicateRewriter &gt;&gt; SegmentIterator::(_rewrite_predicates()&gt;&gt; init())</span><br><span class="line">PredicateParser &gt;&gt; TabletScanner</span><br></pre></td></tr></table></figure>
<h3 id="Task-package"><a href="#Task-package" class="headerlink" title="Task package"></a>Task package</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EngineTask &gt;&gt; (EngineStorageMigrationTask|EnginePublishVersionTask|EngineCloneTask|EngineChecksumTask|EngineBatchLoadTask|EngineAlterTabletTask)</span><br></pre></td></tr></table></figure>
<h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_sink -&gt; tablet_sink -&gt;  LoadChannel-&gt;TabletsChannel-&gt;DeltaWriter-&gt;rowset_writer</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/08/Clickhouse%E5%88%86%E4%BA%AB-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/08/Clickhouse%E5%88%86%E4%BA%AB-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4/" class="post-title-link" itemprop="url">Clickhouse分享: 读已提交</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-08 12:30:11" itemprop="dateCreated datePublished" datetime="2021-11-08T12:30:11+08:00">2021-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>总结之前的<code>原子写入文章</code>, 其实<code>原子写入解决</code>的是<code>数据脏写</code>的问题, 但是存在<code>数据脏读</code>的问题, 即当写入失败回退时, 部分成功的节点的数据, 已经能够被访问了.</p>
<p>那么从数据库经典的事务级别来说, 实现原子写入就实现了ACID的<code>原子性</code>, 但由于<code>脏读</code>状态的存在, 目前的事务级是<code>读未提交</code>.</p>
<p><code>读未提交</code>实际上在OLAP应用中, 对大多数业务的影响并没有那么大, 相对于总数为亿行级别的数据, 单次写入个数在10万以内, 因此数据的误差只有万分之一到千分之一, 在大多数业务系统中并不会有那么大的影响.</p>
<p>但对于某些数据量比较小的用户, <code>读未提交</code>还是会对他们产生比较大的疑问, 因此实现<code>读已提交</code>的隔离级别, 虽非必要, 但是最好如此.</p>
<blockquote>
<p>OLAP系统究竟需要怎么样的隔离级别, 这是一个非常好的问题. 隔离级别需要应用层来确定, 但从目前观察到的业务状态, <code>重复读</code>其实在OLAP中没有必要, 因为OLAP系统中, 用户的SQL很多有依赖关系, 不会出现SQL2的某些数值, 需要从SQL1的结果中获取的场景, 因此<code>可重复读</code>基本上没有实现的意义.</p>
</blockquote>
<h2 id="实现读已提交"><a href="#实现读已提交" class="headerlink" title="实现读已提交"></a>实现读已提交</h2><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20211108150144214.png" alt="image-20211108150144214"></p>
<p>在这个架构中需要引入全局的Zookeeper作为协调者. 在ZK上会维护一个<code>processing_insert</code>的文件夹, 其中每个文件表示正在写入的批次信息, 大多数情况下该目录下只有一个文件, 因为一般只有一个写入的Flink的任务在工作.</p>
<p>和<code>原子写入</code>一样, 一次Flink的Snapshot批次开始的时候, 会产生一个Label, 并写入到ZK中,  之后所有的写入都复用该Label, 每次攒批写入也都有自己的Label, 每个写入的DP都有一个<code>insert_id</code>和一个<code>batch_id</code></p>
<p>和<code>原子写入</code>不一样的是, 如果在snapshot过程读取数据的话, 读引擎会去ZK中拿到<code>processing_insert</code>路径, 并获取到其中的<code>batch_id</code>, 读取数据的时候, 会自动过滤该id, 也就是这个snapshot批次写入的数据, 读不可见.</p>
<blockquote>
<p>这里写入local表的时候,  不需要设计2个状态的DP,  查询的可见性由计算层来维护了</p>
</blockquote>
<p>出现回滚的时候,  会将历史所有的数据删除, 这里不需要删除ZK上的记录, 因为下一次Flink重启的时候<code>batch_id</code>依然是上次的, 数据写入将会重试, 然后就没必要删除数据了.</p>
<blockquote>
<p>删除数据必须要设置为幂等的,  如果删除数据一致无法成功, 此时只能保障让人工来处理. </p>
</blockquote>
<p>对于重试的问题, 和<code>原子写入</code>一样, <code>batch_id</code>相同并且<code>insert_id</code>不同, 因此在<code>prepare</code>的时候需要执行<code>commit</code>local table的操作.</p>
<blockquote>
<p>为什么使用Label而不是使用时间戳? 一, 分布式时间戳生成比较麻烦; 二, Flink写入一半只有一个, 只需要判断两种状态, 不需要判断前后时序关系</p>
</blockquote>
<h2 id="Flink集成"><a href="#Flink集成" class="headerlink" title="Flink集成"></a>Flink集成</h2><p>跟<code>原子写入</code>一样通过两阶段写入的方式处理, 但过程有点不一致:</p>
<ul>
<li>prepare阶段: 执行local的表的commit操作, 写入DP, 并删除无用的DP, 此时local查询时, 该DP已经可见</li>
<li>commit阶段: 只删除ZK上的路径, 查询时会自动查询底层的数据.</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/24/Clickhouse%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E5%8E%9F%E5%AD%90%E5%86%99%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/24/Clickhouse%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-%E5%8E%9F%E5%AD%90%E5%86%99%E5%85%A5/" class="post-title-link" itemprop="url">Clickhouse分享:原子写入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-24 14:28:33" itemprop="dateCreated datePublished" datetime="2021-08-24T14:28:33+08:00">2021-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>众所周知, Clickhouse是没有事务能力的, 对写入数据也不承诺原子性保护,  但在业务使用过程中, 用户往往需要数据量尽量一致, 现在在使用CK时, 用户经常在校对离线和实时数据时, 发现数据行数都不一致.</p>
<p>因此, 我们需要给力CK加上一个原子性写入的保护, 但基于OLAP系统的吞吐量, 给CK加强一致事务保护是不现实的, 所以我们的目标并不是100%的原子性, 而是一个折中.</p>
<p>有个要注意的点, 这篇文章讨论的是写入的<code>原子性</code>, 它只能保证写入要么全部成功, 那么全部失败; 它能保证<code>最终一致性</code>, 但无法保证强一致性; 也<code>无法承诺任何隔离性</code>; 但可以保证持久性.</p>
<blockquote>
<p>实际上用ACID来评价这个原子性, 并不是很恰当, 例如<code>最终一致性</code>是分布式复制协议里面的概念; 这里只是用数据库的ACID做为评价的指标.</p>
</blockquote>
<h2 id="实时数据写入流程"><a href="#实时数据写入流程" class="headerlink" title="实时数据写入流程"></a>实时数据写入流程</h2><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210824150229371.png" alt="image-20210824150229371"></p>
<p>目前实时数据导入的流程大致入上图所示:</p>
<ol>
<li><p>数据存储在Kafka中,  数据从Kafka读取, 并流向Flink程序. 由于Flink有比较完善的Checkpoint机制, 只要Source能够<strong>回放</strong>, 就能保证数据是一致的. 因此这个步骤不会丢失数据</p>
</li>
<li><p>数据在Flink中做完转化后, 会写入到CHProxy中. CHProxy是一个Clickhouse的代理, 负责鉴权或者流程控制等功能. 这个步骤比较容易丢数据,  因为Flink要求Sink算子能够<strong>幂等写入</strong>, 但CHProxy和Clickhouse现有功能都无法保证.</p>
</li>
<li><p>CHProxy接受到写入请求后, 会随机选择一个Clickhouse后端执行写入SQL. 由于随机选择, Flink重试后有可能导致数据写入到不同shard节点, 导致<strong>重复</strong></p>
<blockquote>
<ol>
<li>Flink选CHProxy也是随机的</li>
<li>写入时, 直接写入本地表, 数据没有做hash</li>
</ol>
</blockquote>
</li>
<li><p>Clickhouse节点接收到SQL请求后, 会将数据按照分区切分数据, 写入临时文件, 再分批提交.  提交过程失败, 会导致任务重试后<strong>数据重复</strong>(部分提交成功的情况)</p>
</li>
<li><p>多replica集群,  数据写入到主节点后, 会<strong>异步的同步</strong>到从节点, 此时主节点下线会导致<strong>数据丢失</strong> (节点重启后, 还能恢复)</p>
</li>
</ol>
<p>从上面的分析可知, 2,3,4,5都存在着数据重复或者丢失的风险,  其中2和3是机制问题, 一旦触发Flink重试(重启应用必然触发)/CHProxy随机路由(重试写入时就触发), 数据就会出现大概率重复. 而4和5是小概率实践, 4是一个磁盘写入操作, 即使顺序执行多个DP操作时, 出现异常的概率都是相对较小的;5的情况, 只要节点能够重启, 就能够保证最终一致性.</p>
<p>综上所示, 原子写入的目标是修改2和3的逻辑, 保证数据丢失重复的概率不高于4和5.</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p> 二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时<strong>保持一致性</strong>而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。</p>
<p> 在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。</p>
<p> <strong>当一个事务跨越多个节点时</strong>，<strong>为了保持事务的ACID特性</strong>，需要<strong>引入一个作为协调者的组件</strong>来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。</p>
<p> 因此，<strong>二阶段提交的算法思路可以概括为：</strong> <strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
<p>所谓的两个阶段是指：</p>
<ul>
<li><p><strong>第一阶段：投票</strong></p>
<p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下：</p>
<ol>
<li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果；</li>
<li>事务参与者收到请求之后，执行事务但不提交，并记录事务日志；</li>
<li>参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。</li>
</ol>
</li>
<li><p><strong>第二阶段：事务提交</strong></p>
<p>在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在 3 种可能性：</p>
<ol>
<li>所有的参与者都回复能够正常执行事务。</li>
<li>一个或多个参与者回复事务执行失败。</li>
<li>协调者等待超时。</li>
</ol>
</li>
</ul>
<p>对于第 1 种情况，协调者将向所有的参与者发出提交事务的通知，具体步骤如下：</p>
<ol>
<li>协调者向各个参与者发送 commit 通知，请求提交事务；</li>
<li>参与者收到事务提交通知之后执行 commit 操作，然后释放占有的资源；</li>
<li>参与者向协调者返回事务 commit 结果信息。</li>
</ol>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/bV0KNR.png" alt="2pc-success"></p>
<p>对于第 2 和第 3 种情况，协调者均认为参与者无法成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，具体步骤如下：</p>
<ol>
<li>协调者向各个参与者发送事务 rollback 通知，请求回滚事务；</li>
<li>参与者收到事务回滚通知之后执行 rollback 操作，然后释放占有的资源；</li>
<li>参与者向协调者返回事务 rollback 结果信息。</li>
</ol>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/bV0KOc.png" alt="2pc-failed"></p>
<p>两阶段提交协议原理简单、易于实现，但是缺点也是显而易见的，包含如下：</p>
<ul>
<li><strong>单点问题</strong>: 协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，就会影响整个数据库集群的正常运行。比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或回滚通知，那么参与者们将一直处于阻塞状态，整个数据库集群将无法提供服务。 <strong>极端情况下, 协调者发出Commmit消息之后宕机</strong>,  整体系统将存储不确定的状态.</li>
<li><strong>同步阻塞</strong>: 两阶段提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他操作，这样效率极其低下。</li>
<li><p><strong>数据不一致性</strong>: 两阶段提交协议虽然是分布式数据强一致性所设计，但仍然存在数据不一致性的可能性。比如在第二阶段中，假设协调者发出了事务 commit 通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p>
<p>针对上述问题可以引入 <strong>超时机制</strong> 和 <strong>互询机制</strong> 在很大程度上予以解决。</p>
</li>
</ul>
<p>对于协调者来说如果在指定时间内没有收到所有参与者的应答，则可以自动退出 WAIT 状态，并向所有参与者发送 rollback 通知。对于参与者来说如果位于 READY 状态，但是在指定时间内没有收到协调者的第二阶段通知，则不能武断地执行 rollback 操作，因为协调者可能发送的是 commit 通知，这个时候执行 rollback 就会导致数据不一致。</p>
<p>此时，我们可以介入互询机制，让参与者 A 去询问其他参与者 B 的执行情况。如果 B 执行了 rollback 或 commit 操作，则 A 可以大胆的与 B 执行相同的操作；如果 B 此时还没有到达 READY 状态，则可以推断出协调者发出的肯定是 rollback 通知；如果 B 同样位于 READY 状态，则 A 可以继续询问另外的参与者。只有当所有的参与者都位于 READY 状态时，此时两阶段提交协议无法处理，将陷入长时间的阻塞状态。</p>
<blockquote>
<p>上文的介绍摘抄自<a href="https://segmentfault.com/a/1190000012534071">参考文档</a></p>
</blockquote>
<h2 id="Flink中的两阶段提交"><a href="#Flink中的两阶段提交" class="headerlink" title="Flink中的两阶段提交"></a>Flink中的两阶段提交</h2><p>Flink提供了基于2PC的SinkFunction，名为TwoPhaseCommitSinkFunction，帮助我们做了一些基础的工作。它的第一层类继承关系如下：</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/v2-16e2dc211fae60c8df956546ae465ce6_720w.jpg" alt="img"></p>
<p>但是TwoPhaseCommitSinkFunction仍然留了以下四个抽象方法待子类来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> TXN <span class="title function_">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">preCommit</span><span class="params">(TXN transaction)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TXN transaction)</span>;</span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(TXN transaction)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>beginTransaction()：开始一个事务，返回事务信息的句柄。</p>
</li>
<li><p>preCommit()：预提交（即提交请求）阶段的逻辑, 在snapshotState()方法被调用</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/v2-3d7059f46f5b1557742cf866e10a7e20_720w.jpg" alt="img"></p>
<p>每当需要做checkpoint时，JobManager就在数据流中打入一个屏障（barrier），作为检查点的界限。屏障随着算子链向下游传递，每到达一个算子都会触发将状态快照写入状态后端(state BackEnd)的动作。当屏障到达Kafka sink后，触发preCommit(实际上是KafkaProducer.flush())方法刷写消息数据，但还未真正提交。接下来还是需要通过检查点来触发提交阶段。</p>
</li>
<li><p>commit()：正式提交阶段的逻辑, 该方法的调用点位于TwoPhaseCommitSinkFunction.notifyCheckpointComplete()方法中</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/v2-e5933278ad5c34eb94e7a712fd61ae90_720w.jpg" alt="img"></p>
<p>可见，只有在所有检查点都成功完成这个前提下，写入才会成功。这符合前文所述2PC的流程，其中JobManager为协调者，各个算子为参与者（不过只有sink一个参与者会执行提交）。一旦有检查点失败，notifyCheckpointComplete()方法就不会执行。如果重试也不成功的话，最终会调用abort()方法回滚事务。</p>
</li>
<li><p>abort()：取消事务, 在这里执行Rollback操作</p>
</li>
</ul>
<p>从Flink的实现, 再回看两阶段提交的问题:</p>
<ol>
<li><p>单点问题, 依然存在, Flink只会重启再重试, 但当代码未触发Rollback而异常退出时, Flink实际上对此没有能力</p>
</li>
<li><p>同步阻塞, Clickhouse并没有写入锁, 因此本身就没有这类问题. <strong>事务超时处理可以由应用层完成</strong></p>
</li>
<li><p>数据不一致, Flink有Rollback的接口, 再正常情况下能够保证数据最终一致, 但无法保证强一致性. 在单点问题发生时, Flink连最终一致性也无法保证. 而且数据不一致时, 并没有<strong>互询机制</strong>对账.</p>
</li>
</ol>
<h2 id="Clickhouse两阶段写入"><a href="#Clickhouse两阶段写入" class="headerlink" title="Clickhouse两阶段写入"></a>Clickhouse两阶段写入</h2><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210824191907998.png" alt="image-20210824191907998" style="zoom:50%;" /></p>
<h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>跟现在写tmp文件夹一样, 让DP写入的地方写入到一个叫做<code>draft</code>的文件夹. 类似<code>detach</code>目录, 查询时这些数据不可见, 同时也不会触发<code>Merge</code>以及<code>Mutation</code>操作.</p>
<p>Prepare过程会设置两个Label标志, 第一个标志Flink的CP编号, 第二个标志插入数据的标志. Label可以由客户端设置, 也可以让系统自动生成.</p>
<p>Insert语句会包含返回值, 返回的内容为: Host节点名 + Lable_CP名称 + Lable_name名称 </p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>Commit过程类似于Attach,  Commit需要提供对应的Lable_name列表, 只会Commit对应Label的DataPart.</p>
<p>另外由于Commit可能会处于Unknown状态,  那么需要能够实现多次commit, 用于第一次失败后的重试.</p>
<h3 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h3><p>触发回滚时, DataPart可能会处于Draft或者Visible状态,  对于Draft状态的DataPart只需要删除文件即可.</p>
<p>但是对于Visible状态的DataPart, 需要防止数据被Merge, 导致无法回滚, 此时要求</p>
<ol>
<li>只能Merge相同Label_CP的DataPart, 不同Label_CP的DP不会merge, Mutation后依然保留Label_CP标志</li>
<li>超过Flink Checkpoint间隔后, 可以解除Merge限制, 该时间限制由commit命令的配置项传递 </li>
</ol>
<p>这样既能保证Rollup正确执行, 也保证DP个数不会太多, 导致节点负载高.</p>
<blockquote>
<p>Draft或者Visible状态只是一种描述, 并非CK内部的DP状态类型.</p>
</blockquote>
<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>Flink重启后, 不一定能够下发Rollback命令, 因此需要有一个定时的线程来删除Draft的数据.</p>
<p>默认清理1天前的数据, Clickhouse的插入语句, 不允许执行一天.</p>
<h3 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h3><p>CK的物化视图的更新发生在插入过程中, 因此在插入的时候, 需要对物化视图产生的DP, 打上相同的Label标签. </p>
<p>由于物化视图是分布式写入, 因此每个节点都可能有对应的数据块, 因此插入物化视图时, 返回的数据行数会很多.</p>
<h3 id="DDL变更"><a href="#DDL变更" class="headerlink" title="DDL变更"></a>DDL变更</h3><p>Prepare过程中, 按照老的元数据写入数据, 但是commit阶段, 元数据已经改变.</p>
<p>此时Commit DP时, 需要执行Mutation, 这可能导致Commit时间过长, 导致超时, 但如果是异步处理的话, 可能无法完成.</p>
<h3 id="集群扩缩容"><a href="#集群扩缩容" class="headerlink" title="集群扩缩容"></a>集群扩缩容</h3><p>集群扩容的时候, 比较简单, 主要按照原有的流程处理即可.</p>
<p>但缩容的过程, 由于节点下线, 导致对于该shard的commit,永远都不会成功, 这样就必然会触发Flink的重试, 而整个集群上所有Flink任务的重试, 对业务来说是无法接受的. </p>
<p>因此需要实现下线时,  流量转发的能力, 将commit的请求, 随着数据的迁移而转发, 服务进程依然会提供服务, 知道flink上依赖的任务全部解除依赖(新的一轮snapshot过程即可解除, 删除对应链接通路即可.)</p>
<h2 id="对比Doris"><a href="#对比Doris" class="headerlink" title="对比Doris"></a>对比Doris</h2><p>对于原子插入, Doris处理方式基本一致, 但是Doris的方案能够保证一致性和隔离性, 原因在于<strong>Doris有统一的元数据</strong></p>
<p>Doris在查询时,  FE会指明那些数据是可见的,  因此Doris的可见性(实际上就是隔离性)可以在FE上通过原子的更新改变.</p>
<p>而CK没有统一的元数据, 因此需要向每个节点发送commit, 单个节点commit后无法了解全局的Commit,  因此一旦出现全局回滚, 就会出现不一致的问题.</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1Dq4y1S7Ws">Doris分享视频</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/20/Clickhouse%E8%BF%90%E7%BB%B4%E5%A2%9E%E5%BC%BA-%E7%BB%9F%E4%B8%80%E5%85%83%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/20/Clickhouse%E8%BF%90%E7%BB%B4%E5%A2%9E%E5%BC%BA-%E7%BB%9F%E4%B8%80%E5%85%83%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">Clickhouse运维增强:统一元数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-20 11:16:56" itemprop="dateCreated datePublished" datetime="2021-08-20T11:16:56+08:00">2021-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>51</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Clickhouse元数据"><a href="#Clickhouse元数据" class="headerlink" title="Clickhouse元数据"></a>Clickhouse元数据</h2><h3 id="库表相关"><a href="#库表相关" class="headerlink" title="库表相关"></a>库表相关</h3><h3 id="列相关"><a href="#列相关" class="headerlink" title="列相关"></a>列相关</h3><h3 id="复制相关"><a href="#复制相关" class="headerlink" title="复制相关"></a>复制相关</h3><h2 id="Paxos-vs-MySQL"><a href="#Paxos-vs-MySQL" class="headerlink" title="Paxos vs MySQL"></a>Paxos vs MySQL</h2><h2 id="统一元数据设计"><a href="#统一元数据设计" class="headerlink" title="统一元数据设计"></a>统一元数据设计</h2><h3 id="库表管理"><a href="#库表管理" class="headerlink" title="库表管理"></a>库表管理</h3><h3 id="数据变更"><a href="#数据变更" class="headerlink" title="数据变更"></a>数据变更</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/16/Clickhouse%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-SQL%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/16/Clickhouse%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-SQL%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Clickhouse技术分享: SQL查询流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-16 15:38:58" itemprop="dateCreated datePublished" datetime="2021-08-16T15:38:58+08:00">2021-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="SQL流程概览"><a href="#SQL流程概览" class="headerlink" title="SQL流程概览"></a>SQL流程概览</h2><p>数据库发展至今, SQL处理流程已经非常完善,  以Presto的分析流程为例</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/v2-88847346d6a1d998a2c933f7df9ca0f2_720w.jpg" alt="img"></p>
<ol>
<li>SQL文本由客户端提交到服务端时, 首先会进入Parser模块, 进行<code>词法和语法解析</code></li>
<li>经过解析后, 会生成AST(abstract syntax code)树, 然后会进入<code>语义分析</code>阶段, 结合元数据信息, 将AST中无意义的文本, 转化为有含义的对象.</li>
<li>然后根据AST树, 转化为<code>逻辑计划</code></li>
<li>逻辑计划经过<code>优化器</code>(optimizer)后, 生成最终执行的执行计划(在Presto是分布式执行计划)</li>
<li>最后放入<code>执行器</code>执行具体任务</li>
</ol>
<p>Clickhouse的流程也基本相似:</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210816161057679.png" alt="image-20210816161057679"></p>
<ol>
<li>客户单通过TCP端口提交任务到<code>Clickhouse Server</code></li>
<li><code>TCP Handler</code>会响应请求, 并调用<code>executeQuery</code>函数处理请求</li>
<li><code>executeQuery</code>会处理上面SQL处理的5个步骤, 最后生成执行计划<ol>
<li>Parser为词法解析</li>
<li>Interpreter为语义解析</li>
<li>QueryPlan为逻辑计划</li>
<li>QueryPipeline为经过优化的执行计划</li>
</ol>
</li>
<li>将<code>QueryPipeline</code>放入到<code>PipelineExecutor</code>中执行任务</li>
</ol>
<blockquote>
<p>注: 由于Clickhouse并非一个MPP的数据库, 因此并没有分布式执行计划一说, 分布式方式被拆散到QueryPlan之中.</p>
</blockquote>
<h2 id="TCPHandler"><a href="#TCPHandler" class="headerlink" title="TCPHandler"></a>TCPHandler</h2><p>通过TCP端口(CK默认的客户端)连接的请求会在<code>TCPHandler::runImpl()</code>函数中被处理, 在做完一些准备工作后, 他会执行以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Processing Query</span></span><br><span class="line">state.io = <span class="built_in">executeQuery</span>(state.query, query_context, <span class="literal">false</span>, state.stage, may_have_embedded_data);</span><br><span class="line"><span class="keyword">if</span> (state.need_receive_data_for_input) <span class="comment">// It implies pipeline execution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// It is special case for input(), all works for reading data from client will be done in callbacks.</span></span><br><span class="line">    <span class="keyword">auto</span> executor = state.io.pipeline.<span class="built_in">execute</span>();</span><br><span class="line">    executor-&gt;<span class="built_in">execute</span>(state.io.pipeline.<span class="built_in">getNumThreads</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>executeQuery</code>的输入<code>state.query</code>是String类型, 实际上就是客户端的SQL语句,  输出<code>state.io</code>输出对象为<code>BlockIO</code>, 这是一个<code>QueryPipeline</code>的封装</p>
<p>最终<code>executeQuery</code>将SQL字符串转化为执行计划.</p>
<p>然后调用<code>pipeline.execute()</code>获得计划执行器, 然后调用<code>execute</code>开始任务的执行.</p>
<blockquote>
<p><code>TCPHandler</code>类的实现挺不错的,  整体的细节都封装在<code>executeQuery</code>和<code>PipelineExecutor</code>之中</p>
</blockquote>
<h2 id="executeQuery"><a href="#executeQuery" class="headerlink" title="executeQuery"></a>executeQuery</h2><p><code>executeQuery</code>的实现函数为<code>executeQueryImpl</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ASTPtr ast;</span><br><span class="line"><span class="function">ParserQuery <span class="title">parser</span><span class="params">(end)</span></span>;</span><br><span class="line">ast = <span class="built_in">parseQuery</span>(parser, begin, end, <span class="string">&quot;&quot;</span>, max_query_size, settings.max_parser_depth);</span><br><span class="line"><span class="keyword">auto</span> interpreter = InterpreterFactory::<span class="built_in">get</span>(ast, context, <span class="built_in">SelectQueryOptions</span>(stage).<span class="built_in">setInternal</span>(internal));</span><br><span class="line">BlockIO res = interpreter-&gt;<span class="built_in">execute</span>();</span><br><span class="line">QueryPipeline &amp; pipeline = res.pipeline;</span><br><span class="line"><span class="comment">// 设置一些回调函数, 还有一些querylog</span></span><br></pre></td></tr></table></figure>
<p>首先, 使用<code>ParserQuery</code>将SQL语句转化为AST树(代码在<code>parseQuery.cpp</code>中)</p>
<p>其次, 使用工厂方法<code>InterpreterFactory::get</code>根据AST树, 创建出对应的<code>Interpreter</code>,  我们关注查询, 对应的是<code>InterpreterSelectQuery</code></p>
<p>然后, 调用<code>Interpreter</code>的<code>execute</code>方法生成了最终的执行计划</p>
<p>最后, 设置一些回调函数和queryLog等执行后的处理内容.</p>
<blockquote>
<p>这里将语法解析步骤和后面的语义分析步骤分开, 导致代码可读性降低了, 一下子很难找到例如优化器部分的代码了</p>
</blockquote>
<h3 id="parseQuery"><a href="#parseQuery" class="headerlink" title="parseQuery"></a>parseQuery</h3><p>Clickhouse的Parser模块是自己通过代码实现的, 而非通过现有的库实现, 这样语法解析的性能会好很多.</p>
<p>拆解整个<code>parseQuery</code>的调用链: <code>parseQuery -&gt; parseQueryAndMovePosition -&gt; tryParseQuery -&gt; parser.parse</code></p>
<p>最后还是调用了<code>IParser::parse</code>方法, <code>IParser</code>有一个子类<code>IParserBase</code>实现了<code>parse</code>函数, 但又派生了自己的一个<code>parseImpl</code>方法, 所有的Parser都是<code>IParserBase</code>的子类, 并且实现了<code>parseImpl</code>方法. </p>
<p>在<code>executeQuery</code>定义的<code>ParserQuery</code>可以看做所有Parser的代理类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParserQuery::parseImpl</span><span class="params">(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ParserQueryWithOutput <span class="title">query_with_output_p</span><span class="params">(end)</span></span>;</span><br><span class="line">    <span class="function">ParserInsertQuery <span class="title">insert_p</span><span class="params">(end)</span></span>;</span><br><span class="line">    ParserUseQuery use_p;</span><br><span class="line">    ParserSetQuery set_p;</span><br><span class="line">    <span class="comment">// 省略其他的一些ParserQuery</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> res = query_with_output_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">        || insert_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">        || use_p.<span class="built_in">parse</span>(pos, node, expected)</span><br><span class="line">        || set_role_p.<span class="built_in">parse</span>(pos, node, expected);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个类, 将所有的Parser放到自己内, 我们跟着的<code>Select</code>语句的Parser封装在第一个<code>ParserQueryWithOutput</code></p>
<p>整个路径为<code>ParserQueryWithOutput -&gt; ParserSelectWithUnionQuery -&gt;ParserUnionQueryElement -&gt;ParserSelectQuery</code></p>
<p>最后追踪到<code>ParserSelectQuery::parseImpl</code>开始解析<code>Select</code>语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParserSelectQuery::parseImpl</span><span class="params">(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> select_query = std::<span class="built_in">make_shared</span>&lt;ASTSelectQuery&gt;();</span><br><span class="line">    node = select_query;</span><br><span class="line"></span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_select</span><span class="params">(<span class="string">&quot;SELECT&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ParserKeyword <span class="title">s_all</span><span class="params">(<span class="string">&quot;ALL&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 省略很多代码</span></span><br><span class="line">    ASTPtr with_expression_list;</span><br><span class="line">    ASTPtr select_expression_list;</span><br><span class="line">    <span class="comment">// 省略很多代码</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 开始解析字符</span></span><br><span class="line">    <span class="comment">/// FROM database.table or FROM table or FROM (subquery) or FROM tableFunction(...)</span></span><br><span class="line">    <span class="keyword">if</span> (s_from.<span class="built_in">ignore</span>(pos, expected))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">ParserTablesInSelectQuery</span>().<span class="built_in">parse</span>(pos, tables, expected))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/// PREWHERE expr</span></span><br><span class="line">    <span class="keyword">if</span> (s_prewhere.<span class="built_in">ignore</span>(pos, expected))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!exp_elem.<span class="built_in">parse</span>(pos, prewhere_expression, expected))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意到解析开始时, 先定义了一个<code>ASTSelectQuery</code>,  <code>IAST</code>是抽象语法树的实现, 每个语句几乎都对应着一个语法树.</p>
<p>Parser目的就是通过SQL文本解析, 将AST树构建出来, 赋值里面的具体数值, 例如<code>ASTSelectQuery</code>就需要将这些参数都给赋值了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ASTSelectQuery</span> : <span class="keyword">public</span> IAST</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> distinct = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> group_by_with_totals = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> group_by_with_rollup = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> group_by_with_cube = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> group_by_with_constant_keys = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> limit_with_ties = <span class="literal">false</span>;</span><br><span class="line">    ASTs children;</span><br><span class="line">    std::unordered_map&lt;Expression, <span class="type">size_t</span>&gt; positions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外, 在<code>ASTSelectQuery</code>也有很多其他分支AST树, 例如在<code>parseImpl</code>提到的<code>with_expression_list</code>和<code>select_expression_list</code></p>
<p>至此整个抽象语法树已经构建完毕了</p>
<h3 id="InterpreterSelectQuery"><a href="#InterpreterSelectQuery" class="headerlink" title="InterpreterSelectQuery"></a>InterpreterSelectQuery</h3><p>这个类中最重要的是<code>构造函数</code>和<code>execute</code>方法, 构造函数做的是Analyzer的工作, 就是<code>语义分析</code>的过程, 而<code>execute</code>函数做的构建逻辑计划的步骤.</p>
<h4 id="InterpreterSelectQuery-InterpreterSelectQuery"><a href="#InterpreterSelectQuery-InterpreterSelectQuery" class="headerlink" title="InterpreterSelectQuery::InterpreterSelectQuery()"></a>InterpreterSelectQuery::InterpreterSelectQuery()</h4><p>构造函数中有一个非常长的Lambda函数: <code>analyze</code>, 截取其中重要的方法: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax_analyzer_result = <span class="built_in">TreeRewriter</span>(context).<span class="built_in">analyzeSelect</span>();</span><br><span class="line">query_analyzer = std::<span class="built_in">make_unique</span>&lt;SelectQueryExpressionAnalyzer&gt;();</span><br><span class="line">source_header = metadata_snapshot-&gt;<span class="built_in">getSampleBlockForColumns</span>(required_columns, storage-&gt;<span class="built_in">getVirtuals</span>(), storage-&gt;<span class="built_in">getStorageID</span>());</span><br><span class="line">result_header = <span class="built_in">getSampleBlockImpl</span>();</span><br><span class="line"><span class="comment">// getSampleBlockImpl函数中</span></span><br><span class="line">query_analyzer = std::<span class="built_in">make_unique</span>&lt;SelectQueryExpressionAnalyzer&gt;()</span><br></pre></td></tr></table></figure>
<p>首先, 通过<code>TreeRewriter</code>将做一些语法树的转化动作</p>
<p>其次, 生成<code>query_analyzer</code></p>
<p>最后, 明确一下整个SQL的<code>source_header</code>和<code>result_header</code>, 也就是需要读取表的字段和输出的字段</p>
<p>这里有三个对象非常关键, 看一下这三个的描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeRewriterResultPtr syntax_analyzer_result;</span><br><span class="line">std::unique_ptr&lt;SelectQueryExpressionAnalyzer&gt; query_analyzer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Is calculated in getSampleBlock. Is used later in readImpl.</span></span><br><span class="line">ExpressionAnalysisResult analysis_result;</span><br></pre></td></tr></table></figure>
<p><code>TreeRewriter</code>是经过语义分析的语法树, 在这里除了完成元数据转义之外,  还有不少的优化器, 这个未来再说.</p>
<p><code>SelectQueryExpressionAnalyzer</code>和<code>ExpressionAnalysisResult</code>是一对, 前者负责把AST树上的表达式拆解掉, 表示为<code>ActionDag</code>, 后者为分析的结果.</p>
<p>至于为啥一个执行动作和执行结果都要暴露出来给<code>InterpreterSelectQuery</code>使用呢,  我感觉是代码写的不够好, 导致这两个对象在使用的时候, 调用比较混乱.</p>
<blockquote>
<p>这部分代码逻辑太复杂了, 后续得专门分析一下</p>
</blockquote>
<p>在<code>语义分析</code>阶段实际上就是需要根据元数据信息, 对文本做语义替换, 并完成校验工作, 查询列存不存在的校验工作.</p>
<h4 id="InterpreterSelectQuery-execute"><a href="#InterpreterSelectQuery-execute" class="headerlink" title="InterpreterSelectQuery::execute()"></a>InterpreterSelectQuery::execute()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockIO <span class="title">InterpreterSelectQuery::execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockIO res;</span><br><span class="line">    QueryPlan query_plan;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">buildQueryPlan</span>(query_plan);</span><br><span class="line"></span><br><span class="line">    res.pipeline = std::<span class="built_in">move</span>(*query_plan.<span class="built_in">buildQueryPipeline</span>(</span><br><span class="line">        QueryPlanOptimizationSettings::<span class="built_in">fromContext</span>(context), BuildQueryPipelineSettings::<span class="built_in">fromContext</span>(context)));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先, 构造<code>QueryPlan</code>, 具体的步骤就是根据AST树, 然后往<code>QueryPlan</code>一直<code>addStep</code></p>
<p><code>IQueryPlanStep</code>算逻辑计划的封装, <code>QueryPlan</code>维系的就是<code>Step</code>的列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QueryPlan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueryPlanStepPtr step;</span><br><span class="line">        std::vector&lt;Node *&gt; children = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Nodes = std::list&lt;Node&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Nodes nodes;</span><br><span class="line">    Node * root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>IQueryPlanStep</code>有5个基础子类:</p>
<ul>
<li>CreatingSetsStep:  Creates sets for subqueries and JOIN.</li>
<li>ISourceStep: Returns single logical DataStream</li>
<li>ITransformingStep:  数据做转化的算子, 大多数的算子都在这里</li>
<li>JoinStep: 处理Jion算子</li>
<li>UnionStep: 处理Union算子</li>
</ul>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210818111008868.png" alt="image-20210818111008868" style="zoom:50%;" /></p>
<p>然后, 有了<code>QueryPlan</code>之后构造执行计划<code>QueryPipeline</code>, 具体代码在<code>QueryPlan::buildQueryPipeline</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueryPipelinePtr <span class="title">QueryPlan::buildQueryPipeline</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">checkInitialized</span>();</span><br><span class="line">    <span class="built_in">optimize</span>(optimization_settings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Frame</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node * node = &#123;&#125;;</span><br><span class="line">        QueryPipelines pipelines = &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    QueryPipelinePtr last_pipeline;</span><br><span class="line"></span><br><span class="line">    std::stack&lt;Frame&gt; stack;</span><br><span class="line">    stack.<span class="built_in">push</span>(Frame&#123;.node = root&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp; frame = stack.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (last_pipeline)</span><br><span class="line">        &#123;</span><br><span class="line">            frame.pipelines.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(last_pipeline));</span><br><span class="line">            last_pipeline = <span class="literal">nullptr</span>; <span class="comment">//-V1048</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> next_child = frame.pipelines.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (next_child == frame.node-&gt;children.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> limit_max_threads = frame.pipelines.<span class="built_in">empty</span>();</span><br><span class="line">            <span class="comment">// 逻辑计划, 转化为执行计划</span></span><br><span class="line">            last_pipeline = frame.node-&gt;step-&gt;<span class="built_in">updatePipeline</span>(std::<span class="built_in">move</span>(frame.pipelines), build_pipeline_settings);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (limit_max_threads &amp;&amp; max_threads)</span><br><span class="line">                last_pipeline-&gt;<span class="built_in">limitMaxThreads</span>(max_threads);</span><br><span class="line"></span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack.<span class="built_in">push</span>(Frame&#123;.node = frame.node-&gt;children[next_child]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; context : interpreter_context)</span><br><span class="line">        last_pipeline-&gt;<span class="built_in">addInterpreterContext</span>(std::<span class="built_in">move</span>(context));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last_pipeline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整段代码有两个核心</p>
<p>第一, 调用了<code>optimize(optimization_settings)</code>方法, 对逻辑计划进行了优化</p>
<p>第二, 遍历整个逻辑树, 分别调用<code>step-&gt;updatePipeline</code>方法, 将逻辑计划转化为执行计划</p>
<p>优化器部分后续再展开, 这里优先讲一下执行计划.</p>
<p>就像逻辑计划, <code>QueryPlan</code>表示逻辑树, <code>IQueryPlanStep</code>表示其中的节点</p>
<p>执行计划的整课树为<code>QueryPipeline</code>,  其中的节点便是<code>IProcessor</code></p>
<p><code>IProcessor</code>有很多的实现, 主要分为3类:</p>
<ol>
<li><p>各种<code>Transform</code>结尾的执行算子, 这些算子与逻辑计划中的<code>ITransformingStep</code>对应</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210818112558755.png" alt="image-20210818112558755" style="zoom:50%;" /></p>
</li>
<li><p>输入相关的, 包含在<code>ISource</code>中, 跟MergeTree读取相关的Source藏匿于<code>SourceWithProcess</code>中</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210818112726000.png" alt="image-20210818112726000" style="zoom:50%;" /></p>
</li>
<li><p>输出相关的, 包含在<code>ISink</code>和<code>IOutputFormat</code>中</p>
</li>
</ol>
<p><code>IProcessor</code>除了定义了处理逻辑, 还需要定位输入输出, 在代码里输入输出, 用<code>Port</code>来表征,  <code>IProcessor</code>可以多个Input也可以有多个output, 因此两者都用列表表示<code>IProcessor</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IProcessor</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  InputPorts inputs;</span><br><span class="line">  OutputPorts outputs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Port</code>定义为如下, 关联<code>IProcessor</code>, 相当于<code>IProcessor</code>关于上下游数据的连接器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Port</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">connect</span><span class="params">(OutputPort &amp;, InputPort &amp;)</span></span>;</span><br><span class="line">    IProcessor * processor = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(OutputPort &amp; output, InputPort &amp; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.state || output.state)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;Port is already connected&quot;</span>, ErrorCodes::LOGICAL_ERROR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> out_name = output.<span class="built_in">getProcessor</span>().<span class="built_in">getName</span>();</span><br><span class="line">    <span class="keyword">auto</span> in_name = input.<span class="built_in">getProcessor</span>().<span class="built_in">getName</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assertCompatibleHeader</span>(output.<span class="built_in">getHeader</span>(), input.<span class="built_in">getHeader</span>(), <span class="string">&quot; function connect between &quot;</span> + out_name + <span class="string">&quot; and &quot;</span> + in_name);</span><br><span class="line"></span><br><span class="line">    input.output_port = &amp;output;</span><br><span class="line">    output.input_port = &amp;input;</span><br><span class="line">    input.state = std::<span class="built_in">make_shared</span>&lt;Port::State&gt;();</span><br><span class="line">    output.state = input.state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>connect</code> 将上下游的<code>IProcessor</code>连接在一起</p>
<p><code>Port</code>有两个实现类:  <code>InputPort</code>和<code>OutputPort</code>表示<code>IProcessor</code>的输入和输出, 并相互关联.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OutputPort</span> : <span class="keyword">public</span> Port</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    InputPort * input_port = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputPort</span> : <span class="keyword">public</span> Port</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    OutputPort * output_port = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PipelineExecutor"><a href="#PipelineExecutor" class="headerlink" title="PipelineExecutor"></a>PipelineExecutor</h2><h3 id="构造PipelineExecutor"><a href="#构造PipelineExecutor" class="headerlink" title="构造PipelineExecutor"></a>构造PipelineExecutor</h3><p><code>PipelineExecutor</code>的构造函数几乎只需要<code>IProcessor</code>列表, 参考<code>QueryPipeline::execute()</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PipelineExecutorPtr <span class="title">QueryPipeline::execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isCompleted</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;Cannot execute pipeline because it is not completed.&quot;</span>, ErrorCodes::LOGICAL_ERROR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;PipelineExecutor&gt;(pipe.processors, process_list_element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PipelineExecutor的构造函数</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        graph = std::<span class="built_in">make_unique</span>&lt;ExecutingGraph&gt;(processors);</span><br><span class="line">        <span class="keyword">if</span> (process_list_element)</span><br><span class="line">            process_list_element-&gt;<span class="built_in">addPipelineExecutor</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Exception &amp; exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造拿到列表, 根据执行计划构造<code>ExecutingGraph</code>, 对应还有<code>ExecutingGraph::Node</code>和<code>ExecutingGraph::Edge</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    IProcessor * processor = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">uint64_t</span> processors_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Edges direct_edges;</span><br><span class="line">    Edges back_edges;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(IProcessor * processor_, <span class="type">uint64_t</span> processor_id)</span><br><span class="line">        : <span class="built_in">processor</span>(processor_), <span class="built_in">processors_id</span>(processor_id)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">uint64_t</span> to_, <span class="type">bool</span> backward_,</span><br><span class="line">         <span class="type">uint64_t</span> input_port_number_, <span class="type">uint64_t</span> output_port_number_,</span><br><span class="line">         std::vector&lt;<span class="type">void</span> *&gt; * update_list)</span><br><span class="line">        : <span class="built_in">to</span>(to_), <span class="built_in">backward</span>(backward_)</span><br><span class="line">        , <span class="built_in">input_port_number</span>(input_port_number_), <span class="built_in">output_port_number</span>(output_port_number_)</span><br><span class="line">    &#123;</span><br><span class="line">        update_info.update_list = update_list;</span><br><span class="line">        update_info.id = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> to = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">bool</span> backward;</span><br><span class="line">    <span class="type">uint64_t</span> input_port_number;</span><br><span class="line">    <span class="type">uint64_t</span> output_port_number;</span><br><span class="line">    Port::UpdateInfo update_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>Node</code>定义着和<code>IProcessor</code>的关系, 而<code>Edge</code>定义着<code>Port</code>的编号</p>
<h3 id="PipelineExecutor执行"><a href="#PipelineExecutor执行" class="headerlink" title="PipelineExecutor执行"></a>PipelineExecutor执行</h3><p>调用链为<code>execute -&gt; executeImpl -&gt; initializeExecution -&gt; executeSingleThread -&gt; executeStepImpl</code> </p>
<p>其中<code>initializeExecution</code>主要是为了初始化ThreadLocal的线程池,  主要的触发逻辑都在<code>executeStepImpl</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeStepImpl的核心逻辑</span></span><br><span class="line"><span class="keyword">while</span> (node &amp;&amp; !yield)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (finished)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">addJob</span>(node);</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;<span class="built_in">job</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;exception)</span><br><span class="line">        <span class="built_in">cancel</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addJob逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PipelineExecutor::addJob</span><span class="params">(ExecutingGraph::Node * execution_state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> job = [execution_state]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Stopwatch watch;</span></span><br><span class="line">            <span class="built_in">executeJob</span>(execution_state-&gt;processor);</span><br><span class="line">            <span class="comment">// execution_state-&gt;execution_time_ns += watch.elapsed();</span></span><br><span class="line"></span><br><span class="line">            ++execution_state-&gt;num_executed_jobs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            execution_state-&gt;exception = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    execution_state-&gt;job = std::<span class="built_in">move</span>(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// executeJob逻辑, 实际上就是调用processor-&gt;work()</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">executeJob</span><span class="params">(IProcessor * processor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        processor-&gt;<span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Exception &amp; exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">checkCanAddAdditionalInfoToException</span>(exception))</span><br><span class="line">            exception.<span class="built_in">addMessage</span>(<span class="string">&quot;While executing &quot;</span> + processor-&gt;<span class="built_in">getName</span>());</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体Clickhouse处理SQL的逻辑就如上面所写的,  整体上实现和SparkSQL挺不一样的, 感觉上SparkSQL相对来说更好理解.</p>
<p>例如你想找一下类型校验的代码,  一般这个代码会写在<code>Analyzer</code>上, 但我粗粗的浏览代码的时候, 就一下子就难以找到. 但是在SparkSQL里面, 你只要搜索<code>TypeCoercion</code>就能找到所有相关的判断规则, 而Clickhouse中到现在依然没有找到.</p>
<blockquote>
<p>代码基于21年8月份的master分支</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAClickhouse-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAClickhouse-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">深入浅出Clickhouse: 分布式设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-15 15:02:01" itemprop="dateCreated datePublished" datetime="2021-08-15T15:02:01+08:00">2021-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">remote_servers</span> <span class="attr">incl</span>=<span class="string">&quot;clickhouse_remote_servers&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">test01</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">host</span>&gt;</span>host01<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>9100<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">host</span>&gt;</span>host02<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>9100<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">internal_replication</span>&gt;</span>true<span class="tag">&lt;/<span class="name">internal_replication</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">host</span>&gt;</span>host03<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>9100<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">host</span>&gt;</span>host04<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>9100<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test01</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">remote_servers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在Clickhouse的<code>config.xml</code>文件中有以上类似配置项内容, 在这个样例里面, 定义了一个叫做<code>test01</code>的集群, 它由4个节点组成,  其中分为2个shard,  2副本.</p>
<p>大致是如下一种形式, shard0和shard1的数据时是不一样的, 而同个shard中的数据时完全一样的.</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210830142321251.png" alt="image-20210830142321251"></p>
<p><strong>Shard内的数据复制能力</strong>, Clickhouse发明了一种叫做<code>ReplicatedMergeTree</code>的引擎, 通过Zookeeper做元数据中心, 完成多个节点建的数据同步. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> default.lineorder_local</span><br><span class="line">(</span><br><span class="line">    `LO_ORDERKEY` UInt32,</span><br><span class="line">    `LO_LINENUMBER` UInt8,</span><br><span class="line">    `LO_CUSTKEY` UInt32,</span><br><span class="line">    `LO_PARTKEY` UInt32,</span><br><span class="line">    `LO_SUPPKEY` UInt32,</span><br><span class="line">    `LO_ORDERDATE` <span class="type">Date</span>,</span><br><span class="line">    `LO_ORDERPRIORITY` LowCardinality(String),</span><br><span class="line">    `LO_SHIPPRIORITY` UInt8,</span><br><span class="line">    `LO_QUANTITY` UInt8,</span><br><span class="line">    `LO_EXTENDEDPRICE` UInt32,</span><br><span class="line">    `LO_ORDTOTALPRICE` UInt32,</span><br><span class="line">    `LO_DISCOUNT` UInt8,</span><br><span class="line">    `LO_REVENUE` UInt32,</span><br><span class="line">    `LO_SUPPLYCOST` UInt32,</span><br><span class="line">    `LO_TAX` UInt8,</span><br><span class="line">    `LO_COMMITDATE` <span class="type">Date</span>,</span><br><span class="line">    `LO_SHIPMODE` LowCardinality(String)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/tables/&#123;shard&#125;/default/lineorder_local&#x27;</span>, <span class="string">&#x27;&#123;replica&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYear(LO_ORDERDATE)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (LO_ORDERDATE, LO_ORDERKEY)</span><br><span class="line">SETTINGS index_granularity <span class="operator">=</span> <span class="number">8192</span></span><br></pre></td></tr></table></figure>
<p><code>ReplicatedMergeTree</code>的建表语句如上所示, 和<code>MergeTree</code>引擎的区别就是<code>ReplicatedMergeTree(&#39;/clickhouse/tables/&#123;shard&#125;/default/lineorder_local&#39;, &#39;&#123;replica&#125;&#39;)</code>这段内容, <code>&#39;/clickhouse/tables/&#123;shard&#125;/default/lineorder_local&#39;</code>表示的是Zookeeper的路径, <code>&#39;&#123;replica&#125;&#39;</code>表示的是replica的序号.</p>
<p><code>&#123;value&#125;</code>这类数值在配置文件夹的<code>macros.xml</code>文件中定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">macros</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cluster</span>&gt;</span>test01<span class="tag">&lt;/<span class="name">cluster</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">shard</span>&gt;</span>test01-01<span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replica</span>&gt;</span>01<span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">macros</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Shard间的分区</strong>,  Clickhouse也创建了一个<code>Distributed</code>数据表引擎表示, 负责写入时数据的分发, 读取时数据的合并.</p>
<p>但是<code>Distributed</code>表不存数据, 因此需要有一个local表存储真实的数据, 上面提到的<code>ReplicatedMergeTree</code>就是数据表.</p>
<p>建表语句如下,  整体的结构与local表一致,  引擎<code>Distributed</code>中, <code>test01</code>表示是cluster, <code>default</code>表示的数据库, <code>lineorder_local</code>表示的是表名, 而<code>xxHash32(LO_ORDERKEY)</code>表示根据这个表达式来分区, 通过<code>xxHash</code>分区可以保证相同的key, 必然在一个Shard内, 这样才能完成后续的去重或者预聚合的功能,.  分布式引擎, 还支持<code>rand</code>方式的分区,  随机分区会减少插入过程中做hash的消耗, 但会存在数据重复的情况, 需要根据情况设置.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> default.lineorder</span><br><span class="line">(</span><br><span class="line">    `LO_ORDERKEY` UInt32,</span><br><span class="line">    `LO_LINENUMBER` UInt8,</span><br><span class="line">    `LO_CUSTKEY` UInt32,</span><br><span class="line">    `LO_PARTKEY` UInt32,</span><br><span class="line">    `LO_SUPPKEY` UInt32,</span><br><span class="line">    `LO_ORDERDATE` <span class="type">Date</span>,</span><br><span class="line">    `LO_ORDERPRIORITY` LowCardinality(String),</span><br><span class="line">    `LO_SHIPPRIORITY` UInt8,</span><br><span class="line">    `LO_QUANTITY` UInt8,</span><br><span class="line">    `LO_EXTENDEDPRICE` UInt32,</span><br><span class="line">    `LO_ORDTOTALPRICE` UInt32,</span><br><span class="line">    `LO_DISCOUNT` UInt8,</span><br><span class="line">    `LO_REVENUE` UInt32,</span><br><span class="line">    `LO_SUPPLYCOST` UInt32,</span><br><span class="line">    `LO_TAX` UInt8,</span><br><span class="line">    `LO_COMMITDATE` <span class="type">Date</span>,</span><br><span class="line">    `LO_SHIPMODE` LowCardinality(String)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> Distributed(<span class="string">&#x27;test01&#x27;</span>, <span class="string">&#x27;default&#x27;</span>, <span class="string">&#x27;lineorder_local&#x27;</span>, xxHash32(LO_ORDERKEY))</span><br></pre></td></tr></table></figure>
<h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><p>在一个shard内的数据流动叫做数据复制, 我们经常听到的<code>一致性协议</code>以及<code>paxos</code>或者<code>raft</code>都在这个范畴之内, 是一个比较复制事情.</p>
<p>Clickhouse实现的时候, 直接引入了Zookeeper作为元数据中心, Zookeeper通过它自己的<code>ZAB</code>实现了<code>一致性协议</code>, 但Zookeeper的QPS不高, 当元数据量太多时, 容易引发瓶颈. 目前社区基于<a href="https://github.com/eBay/NuRaft">NuRaft</a>实现<a href="https://github.com/ClickHouse/ClickHouse/pull/24059">ClickKeeper</a>, 希望替代Zookeeper. 这都是后话, 先不去管理, 基于Zookeeper的分布式复制, 需要完成的两件事情是, <strong>数据插入</strong>和<strong>数据变更</strong>, 我们分情况看一下这两个设计.</p>
<h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210830145322611.png" alt="image-20210830145322611"></p>
<ol>
<li>数据写入shard的一个节点</li>
<li>在本地节点中, 生成DP文件</li>
<li>并将DP写入本地的事件写入到ZK上</li>
<li>其他副本监控着写入时间, 如果发现有数据写入的时间, 就会立刻读取事件. </li>
<li>事件写明了DP的编号以及DP的地址, 副本节点会主动去事件写入节点拿数据</li>
<li>Clickhouse由一个内部端口, 专门用于节点间数据传输, 通过该端口将DP文件传输到节点本地</li>
<li>然后再将DP数据加载到节点内部, 并更新ZK上的信息, 告诉ZK自己已经拿到DP, 并且其他副本也可以从自己这儿下载DP</li>
</ol>
<p>默认情况下, Clickhouse只会写入一个节点, 然后写入请求就接受了, 这种情况下, 一旦主节点挂机, 这份数据就无法被传输, 可以设置配置项<code>insert_quorum</code>强制副本写入其他节点后再返回.</p>
<h3 id="数据变更"><a href="#数据变更" class="headerlink" title="数据变更"></a>数据变更</h3><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210830145330506.png" alt="image-20210830145330506"></p>
<ol>
<li>事件的触发有两种, 一种由内部的<code>merge</code>请求触发, 一种由外部客户端触发的<code>mutation</code>或者<code>alter</code>方法</li>
<li>主节点或者客户端触发变更后, 由响应节点将事件写入到Zookeeper, 写入后该任务就算完成了</li>
<li>其他所有副本都监听这个事件</li>
<li>一旦发现新的变更, 就会自己按照事件内容处理任务</li>
</ol>
<p>由于事件处理效率并不相同, 如果有一个节点, 处理事件晚于其他节点很多, 那么它可能直接去其他节点获取已经变更过的数据, 而非在自己节点完成.</p>
<h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>分布式DDL的逻辑相对来说比较简单,  也是在Zookeeper上写入一条事件记录, 然后每个节点监听执行, 这个步骤就不展开了, 这里只聚焦于分区写入的流程.</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210830152305274.png" alt="image-20210830152305274"></p>
<ol>
<li>数据写入分布式表</li>
<li>接收到数据写入的节点, 将分布式表写入本地的临时文件夹中, 临时文件夹包含远程shard的地址</li>
<li>本地的数据直接attach数据, 然后分批发送远程的数据.</li>
</ol>
<p>分布式插入可以设置为同步插入模式, 需要设置配置项<code>insert_distributed_sync=1</code>.  由于分布式表和local表的分离, 默认的异步插入会产生积压, 此时如果将local表的字段类型修改后, 整个积压任务就会一直异常, 并卡住, 后续的数据都无法插入.</p>
<p>因此, 我们写入数据的时候, 会尽量直接写local表, 不是去重表类型的, 基本上不让用户使用分布式表写入.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAClickhouse-MergeTree%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAClickhouse-MergeTree%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">深入浅出Clickhouse: MergeTree引擎设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-15 14:58:28" itemprop="dateCreated datePublished" datetime="2021-08-15T14:58:28+08:00">2021-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>LSM</code>(Log-Struct Merge Tree)是大数据领域一种非常常见的技术, 例如<code>LevelDB</code>, <code>RocksDB</code>亦或是<code>HBase</code>都采用了<code>LSM</code>结构来完成存储系统的构架.</p>
<p>但你有没有发现, 这些大数据系统, 大多数都是KV方式的存储系统,  对外的接口也是以点查方式提供的.  </p>
<p>虽然例如<code>HBase</code>的RowKey是全局有序的, 但是如果使用RowKey做大规模的范围查询, 它的整体效果可能还比不上在HDFS的文件上直接做过滤更有效.</p>
<p>基于以上的问题, 我们再回顾一下LSM的设计, 解答一下为什么LSM最适合点查, 然后再介绍Clickhouse基于LSM做了哪些取舍, 让MergeTree适合做范围的查询分析.</p>
<h2 id="LSM树回顾"><a href="#LSM树回顾" class="headerlink" title="LSM树回顾"></a>LSM树回顾</h2><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/v2-cbf13812e03058e856dbc97d4a7a495d_1440w.jpg" alt="img"></p>
<p>LSM的架构如上图所示,  数据先存放在Memory中, 然后通过一次的合并, 数据会固化到磁盘上.</p>
<p>为了防止每次合并都处理全部的数据, 因此LSM会将数据分层,  上一层比下一层小很多, 并且上一层的合并频率也比下一层多很多次.</p>
<p>由于需要合并去重的要求, 因此LSM树必须要指定一个类似主键之类的不重复的key.</p>
<p>另外一个点, 在Level-1以上, Key是在不同的文件块中, 是绝对不重复的, 而由于一般多是采用Range分区的方式, 我们可以称LSM树是Key键是<strong>全局有序且不重复</strong>的 </p>
<p>当数据更新的时候, LSM只会将数据标记为删除, 或者更新一个数据的版本,  等到后续做数据合并的时候, 再做去重或者删除数据的动作</p>
<p>这就是所谓的<strong>写放大</strong>问题</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/rocksdb_read_process.png" alt="img"></p>
<p>当读取数据的时候, 会先读取<code>MemTable</code>, 再读取<code>Immutable MemTable</code>, 最后在磁盘上一层一层读取文件, 直到最后读取到数据.</p>
<p>造成<strong>读放大</strong>的原因有两个点: 第一, 数据一旦没有命中, 就要往更深的层查找; 第二, 每个层中, 虽然因为全局有序, 点查只需要扫描一个SST文件, 但必须一次扫描整个SST文件.</p>
<p>总结一下, LSM的特点有:</p>
<ol>
<li>必须有Key键, 且全局有序不重复</li>
<li>写入时, 一层一层写入, 更新删除只做标记</li>
<li>读取时, 一层一层读取, 读取效率在于命中率</li>
</ol>
<p>然后再结合点查询的场景,  回答一下为什么LSM最适合点查:</p>
<ol>
<li>Key键全局有序且不重复, 这样查询时一下就能定位到对应的数据地址,  符合点查对对查询时延的要求</li>
<li>插入修改删除只是在Mem中添加数据, 这里就要求一次插入的数据不能太多, 不然内存存储不下, 就要开始合并, 会导致系统不稳定, 而点查一般一次只修改一行数据, 完美符合</li>
<li>读取数据时候, 时延在于命中率, 而点查询的热点效应明显, 主要在前几层能够命中, 整体读取的效率可以接受.</li>
</ol>
<blockquote>
<p>LSM树相对于B+树来说, 强化了Update和Delete的能力, 相对弱化的读取的能力</p>
</blockquote>
<p>但是如果是范围查询, 就会出现:</p>
<ol>
<li>一次更新数据可能是全部数据的20%以上, 例如修改某个字段的标号, 或者删除某些字段的数据</li>
<li>读取时给一个宽裕的过滤范围, 大多数的数据都能匹配中, 例如一个宽泛的前缀匹配</li>
</ol>
<p>上面两个场景, 如果用LSM树的架构, 基本上是不可取的.</p>
<blockquote>
<p>LSM树的参考<a href="https://zhuanlan.zhihu.com/p/103968892">文章1</a>, <a href="http://alexstocks.github.io/html/rocksdb.html">文章2</a></p>
</blockquote>
<h2 id="Clickhouse-MergeTree设计"><a href="#Clickhouse-MergeTree设计" class="headerlink" title="Clickhouse MergeTree设计"></a>Clickhouse MergeTree设计</h2><p>Clickhouse作为一个OLAP系统放弃了对于点查场景的支持, 而是主要面向范围查询的支持, 因此对于MergeTree做了大刀阔斧的修改.</p>
<p>对于Clickhouse来说, 没有单条的插入, 插入修改都抽象为对DataPart的操作.</p>
<p>DataPart在逻辑可以理解为批量的一组数据, 在物理上是磁盘上的一个文件夹, </p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210823132128627.png" alt="image-20210823132128627"></p>
<p>Clickhouse的数据组织, 如上图所示, 相比于MergeTree:</p>
<ol>
<li>放弃了全局有序的约束, 只保证DataPart级别是有序的,  此时面对OLAP场景的批量插入, 只需要针对当前插入的数据做排序, 并插入为DP即可</li>
<li>放弃了多层的架构,  没有Memory层,  磁盘也只有一层. 在做Mutation(LSM对应Delete和Update)的时候,  也是DataPart到DataPart的转化</li>
</ol>
<p>以上这两个设计的特点, 解决了写入和修改的场景, 但有一个明确的假设条件:  <strong>高吞吐的插入</strong>和 <strong>低频次大数据量的修改</strong></p>
<p>此外这种方式, 比较实现列存模式(一个DP包含很行的数据), 因此天然比较适合OLAP,  而LSM比较适合行存, 一般用于OLTP.</p>
<p>但任何设计都有好坏, 一旦应用场景无法满足Clickhouse假设, 那么整体效果就会比较差:</p>
<ol>
<li>插入批次小: Clickhouse由于不像LSM一样全局有序, 可以明确数据必然在一个数据块中, 因此查询时需要扫描分区裁剪后的所有DP, 因此CK会根据DataPart数量, 合并DataPart, 防止DataPart个数太多,  扫描性能太慢. 但如果插入批次小, 就会不停的触发Merge动作, 导致不必要的资源浪费, 因此都推荐在客户端攒批的方式写入 </li>
<li>修改频次高:  Mutation在Clickhouse被设计为一个非常重的操作, 因为需要处理大量数据, 但如果此时频次一高,  整个系统CPU马上就会上去</li>
<li>数据要求实时去重: 在Clickhouse设计中, DataPart数据间是没有关联的, 只有在Merge时才会产生关系, 但如果需要实时去重, 那么DP之间就会产生关联性(后写入的数据需要覆盖前面写入的数据), 不管后面如何优化, 这类场景的查询和写入都会比原生的差很多.</li>
</ol>
<h2 id="各种MergeTree"><a href="#各种MergeTree" class="headerlink" title="各种MergeTree"></a>各种MergeTree</h2><h3 id="普通MergeTree"><a href="#普通MergeTree" class="headerlink" title="普通MergeTree"></a>普通MergeTree</h3><p>MergeTree表引擎主要用于海量数据分析，支持数据分区、存储有序、主键索引、稀疏索引、数据TTL等。MergeTree支持所有ClickHouse SQL语法，但是有些功能与MySQL并不一致，比如在MergeTree中主键并不用于去重，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_tbl (</span><br><span class="line">  id UInt16,</span><br><span class="line">  create_time <span class="type">Date</span>,</span><br><span class="line">  comment Nullable(String)</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> create_time</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>  (id, create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id, create_time)</span><br><span class="line">TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span></span><br><span class="line">SETTINGS index_granularity<span class="operator">=</span><span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 虽然主键定义为(id, create_time), 但是最后还是5条数据, 并不会改变</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl <span class="keyword">values</span>(<span class="number">0</span>, <span class="string">&#x27;2019-12-12&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl <span class="keyword">values</span>(<span class="number">0</span>, <span class="string">&#x27;2019-12-12&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;2019-12-13&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;2019-12-13&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;2019-12-14&#x27;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="ReplacingMergeTree"><a href="#ReplacingMergeTree" class="headerlink" title="ReplacingMergeTree"></a>ReplacingMergeTree</h3><p>为了解决MergeTree相同主键无法去重的问题，ClickHouse提供了ReplacingMergeTree引擎，用来做去重, 但这个引擎依然有很多限制:</p>
<ul>
<li>在没有彻底optimize之前，可能无法达到主键去重的效果，比如部分数据已经被去重，而另外一部分数据仍旧有主键重复；</li>
<li>在分布式场景下，相同primary key的数据可能被sharding到不同节点上，不同shard间可能无法去重；</li>
<li>optimize是后台动作，无法预测具体执行时间点；</li>
<li>手动执行optimize在海量数据场景下要消耗大量时间，无法满足业务即时查询的需求；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_tbl_replacing (</span><br><span class="line">  id UInt16,</span><br><span class="line">  create_time <span class="type">Date</span>,</span><br><span class="line">  comment Nullable(String)</span><br><span class="line">) ENGINE <span class="operator">=</span> ReplacingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> create_time</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>  (id, create_time)</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id, create_time)</span><br><span class="line">TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span></span><br><span class="line">SETTINGS index_granularity<span class="operator">=</span><span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 写入主键重复的数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl_replacing <span class="keyword">values</span>(<span class="number">0</span>, <span class="string">&#x27;2019-12-12&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl_replacing <span class="keyword">values</span>(<span class="number">0</span>, <span class="string">&#x27;2019-12-12&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl_replacing <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;2019-12-13&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl_replacing <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;2019-12-13&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_tbl_replacing <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;2019-12-14&#x27;</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">-- 此时数据依然为5条</span></span><br><span class="line"><span class="comment">-- 强制后台compaction：</span></span><br><span class="line">optimize <span class="keyword">table</span> test_tbl_replacing <span class="keyword">final</span>;</span><br><span class="line"><span class="comment">-- 此时数据为3条</span></span><br></pre></td></tr></table></figure>
<h3 id="CollapsingMergeTree"><a href="#CollapsingMergeTree" class="headerlink" title="CollapsingMergeTree"></a>CollapsingMergeTree</h3><p>ClickHouse实现了CollapsingMergeTree来消除ReplacingMergeTree的限制。该引擎要求在建表语句中指定一个标记列Sign，后台Compaction时会将主键相同、Sign相反的行进行折叠，也即删除。</p>
<p>CollapsingMergeTree将行按照Sign的值分为两类：Sign=1的行称之为状态行，Sign=-1的行称之为取消行。</p>
<p>每次需要新增状态时，写入一行状态行；需要删除状态时，则写入一行取消行。</p>
<p>在后台Compaction时，状态行与取消行会自动做折叠（删除）处理。而尚未进行Compaction的数据，状态行与取消行同时存在。</p>
<p>因此为了能够达到主键折叠（删除）的目的，需要业务层进行适当改造</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> UAct</span><br><span class="line">(</span><br><span class="line">    UserID UInt64,</span><br><span class="line">    PageViews UInt8,</span><br><span class="line">    Duration UInt8,</span><br><span class="line">    Sign Int8</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> CollapsingMergeTree(Sign)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UserID;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入状态行，注意sign一列的值为1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> UAct <span class="keyword">VALUES</span> (<span class="number">4324182021466249494</span>, <span class="number">5</span>, <span class="number">146</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一行取消行，用于抵消上述状态行。注意sign一列的值为-1，其余值与状态行一致；</span></span><br><span class="line"><span class="comment">-- 并且插入一行主键相同的新状态行，用来将PageViews从5更新至6，将Duration从146更新为185.</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> UAct <span class="keyword">VALUES</span> (<span class="number">4324182021466249494</span>, <span class="number">5</span>, <span class="number">146</span>, <span class="number">-1</span>), (<span class="number">4324182021466249494</span>, <span class="number">6</span>, <span class="number">185</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 查询数据：可以看到未Compaction之前，状态行与取消行共存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为了获取正确的sum值，需要改写SQL： </span></span><br><span class="line"><span class="comment">-- sum(PageViews) =&gt; sum(PageViews * Sign)、 </span></span><br><span class="line"><span class="comment">-- sum(Duration) =&gt; sum(Duration * Sign)</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    <span class="built_in">sum</span>(PageViews <span class="operator">*</span> Sign) <span class="keyword">AS</span> PageViews,</span><br><span class="line">    <span class="built_in">sum</span>(Duration <span class="operator">*</span> Sign) <span class="keyword">AS</span> Duration</span><br><span class="line"><span class="keyword">FROM</span> UAct</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">sum</span>(Sign) <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制后台Compaction</span></span><br><span class="line">optimize <span class="keyword">table</span> UAct <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询，可以看到状态行、取消行已经被折叠，只剩下最新的一行状态行。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> UAct;</span><br></pre></td></tr></table></figure>
<p>CollapsingMergeTree虽然解决了主键相同的数据即时删除的问题，但是状态持续变化且多线程并行写入情况下，状态行与取消行位置可能乱序，导致无法正常折叠。</p>
<h3 id="VersionedCollapsingMergeTree"><a href="#VersionedCollapsingMergeTree" class="headerlink" title="VersionedCollapsingMergeTree"></a>VersionedCollapsingMergeTree</h3><p>为了解决CollapsingMergeTree乱序写入情况下无法正常折叠问题，VersionedCollapsingMergeTree表引擎在建表语句中新增了一列Version，用于在乱序情况下记录状态行与取消行的对应关系。主键相同，且Version相同、Sign相反的行，在Compaction时会被删除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> UAct_version</span><br><span class="line">(</span><br><span class="line">    UserID UInt64,</span><br><span class="line">    PageViews UInt8,</span><br><span class="line">    Duration UInt8,</span><br><span class="line">    Sign Int8,</span><br><span class="line">    Version UInt8</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> VersionedCollapsingMergeTree(Sign, Version)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UserID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先插入一行取消行，注意Signz=-1, Version=1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> UAct_version <span class="keyword">VALUES</span> (<span class="number">4324182021466249494</span>, <span class="number">5</span>, <span class="number">146</span>, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 后插入一行状态行，注意Sign=1, Version=1；及一行新的状态行注意Sign=1, Version=2，将PageViews从5更新至6，将Duration从146更新为185。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> UAct_version <span class="keyword">VALUES</span> (<span class="number">4324182021466249494</span>, <span class="number">5</span>, <span class="number">146</span>, <span class="number">1</span>, <span class="number">1</span>),(<span class="number">4324182021466249494</span>, <span class="number">6</span>, <span class="number">185</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为了获取正确的sum值，需要改写SQL： </span></span><br><span class="line"><span class="comment">-- sum(PageViews) =&gt; sum(PageViews * Sign)、 </span></span><br><span class="line"><span class="comment">-- sum(Duration) =&gt; sum(Duration * Sign)</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    <span class="built_in">sum</span>(PageViews <span class="operator">*</span> Sign) <span class="keyword">AS</span> PageViews,</span><br><span class="line">    <span class="built_in">sum</span>(Duration <span class="operator">*</span> Sign) <span class="keyword">AS</span> Duration</span><br><span class="line"><span class="keyword">FROM</span> UAct_version</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">sum</span>(Sign) <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 强制后台Compaction</span></span><br><span class="line">optimize <span class="keyword">table</span> UAct_version <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询，可以看到即便取消行与状态行位置乱序，仍旧可以被正确折叠。</span></span><br></pre></td></tr></table></figure>
<h3 id="SummingMergeTree"><a href="#SummingMergeTree" class="headerlink" title="SummingMergeTree"></a>SummingMergeTree</h3><p>ClickHouse通过SummingMergeTree来支持对主键列进行预先聚合。在后台Compaction时，会将主键相同的多行进行sum求和，然后使用一行数据取而代之，从而大幅度降低存储空间占用，提升聚合计算性能。</p>
<p>值得注意的是：</p>
<ul>
<li>ClickHouse只在后台Compaction时才会进行数据的预先聚合，而compaction的执行时机无法预测，所以可能存在部分数据已经被预先聚合、部分数据尚未被聚合的情况。因此，在执行聚合计算时，SQL中仍需要使用GROUP BY子句。</li>
<li>在预先聚合时，ClickHouse会对主键列之外的其他所有列进行预聚合。如果这些列是可聚合的（比如数值类型），则直接sum；如果不可聚合（比如String类型），则随机选择一个值。</li>
<li>通常建议将SummingMergeTree与MergeTree配合使用，使用MergeTree来存储具体明细，使用SummingMergeTree来存储预先聚合的结果加速查询。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> summtt</span><br><span class="line">(</span><br><span class="line">    key UInt32,</span><br><span class="line">    <span class="keyword">value</span> UInt32</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> SummingMergeTree()</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> summtt <span class="keyword">Values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- compaction前查询，仍存在多行</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> summtt;</span><br><span class="line">┌─key─┬─<span class="keyword">value</span>─┐</span><br><span class="line">│   <span class="number">1</span> │     <span class="number">1</span> │</span><br><span class="line">│   <span class="number">1</span> │     <span class="number">2</span> │</span><br><span class="line">│   <span class="number">2</span> │     <span class="number">1</span> │</span><br><span class="line">└─────┴───────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过GROUP BY进行聚合计算</span></span><br><span class="line"><span class="keyword">SELECT</span> key, <span class="built_in">sum</span>(<span class="keyword">value</span>) <span class="keyword">FROM</span> summtt <span class="keyword">GROUP</span> <span class="keyword">BY</span> key</span><br><span class="line">┌─key─┬─<span class="built_in">sum</span>(<span class="keyword">value</span>)─┐</span><br><span class="line">│   <span class="number">2</span> │          <span class="number">1</span> │</span><br><span class="line">│   <span class="number">1</span> │          <span class="number">3</span> │</span><br><span class="line">└─────┴────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制compaction</span></span><br><span class="line">optimize <span class="keyword">table</span> summtt <span class="keyword">final</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- compaction后查询，可以看到数据已经被预先聚合</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> summtt;</span><br><span class="line">┌─key─┬─<span class="keyword">value</span>─┐</span><br><span class="line">│   <span class="number">1</span> │     <span class="number">3</span> │</span><br><span class="line">│   <span class="number">2</span> │     <span class="number">1</span> │</span><br><span class="line">└─────┴───────┘</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- compaction后，仍旧需要通过GROUP BY进行聚合计算</span></span><br><span class="line"><span class="keyword">SELECT</span> key, <span class="built_in">sum</span>(<span class="keyword">value</span>) <span class="keyword">FROM</span> summtt <span class="keyword">GROUP</span> <span class="keyword">BY</span> key</span><br><span class="line">┌─key─┬─<span class="built_in">sum</span>(<span class="keyword">value</span>)─┐</span><br><span class="line">│   <span class="number">2</span> │          <span class="number">1</span> │</span><br><span class="line">│   <span class="number">1</span> │          <span class="number">3</span> │</span><br><span class="line">└─────┴────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="AggregatingMergeTree"><a href="#AggregatingMergeTree" class="headerlink" title="AggregatingMergeTree"></a>AggregatingMergeTree</h3><p>AggregatingMergeTree也是预先聚合引擎的一种，用于提升聚合计算的性能。与SummingMergeTree的区别在于：SummingMergeTree对非主键列进行sum聚合，而AggregatingMergeTree则可以指定各种聚合函数。</p>
<p>AggregatingMergeTree的语法比较复杂，需要结合物化视图或ClickHouse的特殊数据类型AggregateFunction一起使用。在insert和select时，也有独特的写法和要求：写入时需要使用-State语法，查询时使用-Merge语法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建立明细表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> visits</span><br><span class="line">(</span><br><span class="line">    UserID UInt64,</span><br><span class="line">    CounterID UInt8,</span><br><span class="line">    StartDate <span class="type">Date</span>,</span><br><span class="line">    Sign Int8</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> CollapsingMergeTree(Sign)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> UserID;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对明细表建立物化视图，该物化视图对明细表进行预先聚合</span></span><br><span class="line"><span class="comment">-- 注意：预先聚合使用的函数分别为： sumState, uniqState。对应于写入语法&lt;agg&gt;-State.</span></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> visits_agg_view</span><br><span class="line">ENGINE <span class="operator">=</span> AggregatingMergeTree() <span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate) <span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">    CounterID,</span><br><span class="line">    StartDate,</span><br><span class="line">    sumState(Sign)    <span class="keyword">AS</span> Visits,</span><br><span class="line">    uniqState(UserID) <span class="keyword">AS</span> Users</span><br><span class="line"><span class="keyword">FROM</span> visits</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> CounterID, StartDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入明细数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> visits <span class="keyword">VALUES</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;2019-11-11&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> visits <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;2019-11-12&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对物化视图进行最终的聚合操作</span></span><br><span class="line"><span class="comment">-- 注意：使用的聚合函数为 sumMerge， uniqMerge。对应于查询语法&lt;agg&gt;-Merge.</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    StartDate,</span><br><span class="line">    sumMerge(Visits) <span class="keyword">AS</span> Visits,</span><br><span class="line">    uniqMerge(Users) <span class="keyword">AS</span> Users</span><br><span class="line"><span class="keyword">FROM</span> visits_agg_view</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> StartDate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> StartDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 普通函数 sum, uniq不再可以使用</span></span><br><span class="line"><span class="comment">-- 如下SQL会报错： Illegal type AggregateFunction(sum, Int8) of argument </span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    StartDate,</span><br><span class="line">    <span class="built_in">sum</span>(Visits),</span><br><span class="line">    uniq(Users)</span><br><span class="line"><span class="keyword">FROM</span> visits_agg_view</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> StartDate</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> StartDate;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>描述和示例皆摘抄自<a href="https://developer.aliyun.com/article/762461">阿里云</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAClickhouse-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAClickhouse-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">深入浅出Clickhouse: 索引结构设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-15 14:55:33" itemprop="dateCreated datePublished" datetime="2021-08-15T14:55:33+08:00">2021-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h2><p>当Clickhouse创建一个表,  会在配置文件<code>path</code>指定的路径下对应数据目录.</p>
<p><strong>数据目录</strong>的路径为:  <code>&#123;path&#125;</code>/<code>data</code>/<code>&#123;database&#125;</code>/<code>&#123;table&#125;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> src (</span><br><span class="line">id Int32,</span><br><span class="line"><span class="keyword">year</span> String,</span><br><span class="line">num Int64,</span><br><span class="line">index a num TYPE minmax GRANULARITY <span class="number">2</span></span><br><span class="line">) Engine <span class="operator">=</span>MergeTree()</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (id, <span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">primary</span> key (id, <span class="keyword">year</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> src <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;2021&#x27;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> src <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;2021&#x27;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> src <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;2020&#x27;</span>,<span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p>例如上面的例子, 在<code>default</code>数据库上创建一个<code>src</code>的表, 如果<code>path</code>是在<code>~/clickhouse/data</code>目录, 那么整个目录为</p>
<p><code>~/clickhouse/data/data/default/src</code> </p>
<p>当插入3次数据后, Clickhouse会再数据目录下,  每次都新建一个目录, 如下图所示, 这种目录在Clickhouse称之为<code>DataPart</code></p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210828175325388.png" alt="image-20210828175325388"></p>
<p>目录的格式为: <code>partition</code>_<code>min_block</code>_<code>max_block</code>_<code>level</code></p>
<ul>
<li><code>partition</code>是分区的值, 根据建表的分区表示计算得来, 是一个规定的值; Clickhouse的目录并非按照分区规整的, 在数据目录下, 只有DataPart这层数据了,  也就是说, 通一个分区可能在多个DataPart上, 如上面的<code>1_1_1_0</code>和<code>1_2_2_0</code></li>
<li><code>min_block</code>和<code>max_block</code>中的<code>block</code>是一个单挑递增的计数器,  插入3次后, 计数器就变成了3. 新的<code>DataPart</code>的<code>min_block</code>和<code>max_block</code>是一样的, 但在后续merge之后, 会变成一个范围值.  </li>
<li><code>level</code>表示DataPart生命年龄, 当出现merge或者mutation操作时, level就会加1</li>
</ul>
<p>举上面例子, 如果执行<code>OPTIMIZE TABLE src</code> , 强制表进行合并, 此时<code>1_1_1_0</code>和<code>1_2_2_0</code>两个DP会强制合并, 合并为<code>1_1_2_1</code>, 新DP的<code>level</code>变成了2, 而<code>min_max_block</code>由合并的DP的值确定.  另外合并只发送在同一个Partition内</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210828180126364.png" alt="image-20210828180126364"></p>
<blockquote>
<p>合并操作, 并不会马上删除老的DP, 而是将其设置为<code>inactive</code>, 读操作只会读取新的DP, 因此上图总共有4个DP, 过一段只会剩下两个DP</p>
</blockquote>
<p>DataPart是存储数据的地方,  以上面的一个DataPart为例:</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210828175418382.png" alt="image-20210828175418382"></p>
<ul>
<li><code>checksums.txt</code>是整个DP的检验和</li>
<li><code>columns.txt</code>表示DP的列结构,  Clickhouse将列字段放在DP级别的原因是,  DP在做mutation的时候, 列可能会出现不一样</li>
<li><code>data.bin</code>存储着所有列的值, 称之为<code>数据块</code></li>
<li><code>data.mrk3</code>是<code>数据块</code>的索引文件</li>
<li><code>default_compression_codec.txt</code>压缩方式</li>
<li><code>minmax_id.idx</code>分区文件的<code>min_max</code>索引</li>
<li><code>partition.dat</code>分区的值</li>
<li><code>primary.idx</code>主键索引, 或者成为一级索引</li>
<li><code>skp_idx_a.idx2</code>和<code>skp_idx_a.mrk3</code> 跳数索引, 或者叫做二级索引.</li>
</ul>
<p>当一个DataPart内数据量比较大的时候, <code>data.bin</code>会按照各自的列拆分为<code>id.bin</code> <code>num.bin</code> <code>year.bin</code>, 同理的还有<code>data.mrk3</code></p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210828183605821.png" alt="image-20210828183605821"></p>
<p>Clickhouse有两层索引, 一层为基于分区的索引, 这个在另外的文章中已经讲过,  它的目的是选择到具体的DP; 另外一层是基于数据排序的索引,  描述的是在一个DP内, 数据时如何组织以及被索引的.</p>
<h2 id="数据索引"><a href="#数据索引" class="headerlink" title="数据索引"></a>数据索引</h2><p>废话不多说, 直接上图, 依然以上面的建表语句为例, 与其中相关的是<code>order by</code> 和 <code>partition by</code>的语法.</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210828183928398.png" alt="image-20210828183928398"></p>
<p>在Clickhouse的一个DataPart中, 数据的逻辑分布可以想象成一个矩阵, 如图中的<code>表示例数据</code>方式陈列.</p>
<p><strong>首先</strong>, 行与行之间的排序并非是固定的, 而是根据<code>order by</code><strong>定义的方式排序</strong>, 例如案例中按照<code>id</code>和<code>year</code>排序, 那么<code>num</code>字段的位置也随着前面字段改变. 另外值得说的一点, 这个排序只是在DP内的, DP之间并没有顺序关系.</p>
<p><strong>其次</strong>, 在物理上Clickhouse将按照每8192行数据切分整个矩阵, 将大矩阵切分为一个一个子矩阵, 在图中用<code>编号</code>来表示. <code>8192</code>的数值由配置项<code>index_granularity</code>决定, 该配置为索引结构中最核心的配置.</p>
<p>Clickhouse的主键索引是一个<strong>稀疏索引</strong>, 它并不存储每一个行的数据, 而是存储每个子矩阵的第一个行数据, 因此8192行数据才会有一个索引值, 索引非常小, 对应的代价就是查找时, 需要用折半查找的方式来查询具体的编号, 复杂度为<code>log(n)</code></p>
<p>主键索引可以是组合索引, 类似于mysql的组合索引, CK在查询时也必须满足<code>最左匹配原则</code>, 即查询时必须从最左的字段匹配起, 一旦有跳过字段方式, 索引将无法命中.</p>
<p><strong>再次</strong>, Clickhouse对于非排序字段的查询, 设计了一种叫做<code>跳数索引</code>的二级索引方式, 名为跳数, 意思是并非记录每个编号内的索引, 而是选择一批编号进行计算, 例如图中是按照2个编号算一个<code>跳数索引</code>的方式. </p>
<p>跳数索引有三种: <code>min_max</code>,<code>set</code>和<code>bloomfilter</code>, 以<code>min_max</code>为例, 它存储的是两个数据块中的最大最小值, 此外跳数索引支持表达式, 但不是所有函数都支持, 支持的函数列表, 可以参考<a href="https://clickhouse.tech/docs/en/engines/table-engines/mergetree-family/mergetree/#table_engine-mergetree-data_skipping-indexes">官网</a></p>
<p>跳数索引主要的目的为判断查询的数值是否存在, 如果不存在则跳过, 由于跳数索引是随机的, 因此的查询复杂度为<code>n</code></p>
<blockquote>
<p>其实不应该叫做<code>二级索引</code>, 因为Clickhouse没有回表的动作, <code>跳数索引</code>选中数据块之后, 就直接通过暴力扫描的方式开始计算了.</p>
</blockquote>
<p><strong>最后</strong>, Clickhouse的数据存放在bin文件中, 这是真正的存储的地方. Clickhouse<strong>并非<code>innodb</code>类似的聚族索引将数据文件和索引放在一起</strong>,  而是数据文件和索引文件分开存储. 图中只列举了<code>num.bin</code>文件, 实际上还有<code>id.bin</code>和<code>year.bin</code>.</p>
<p>数据存储也并非按照8192行方式存储, 而是通过一个个数据块方式存储. 一个数据块大小为64K ~ 1Mb, 如果一个编号的数据太小, 就会将合并多个编号内的数据; 如果一个编号数据又太大, 就会拆分一个编号的数据. 而<code>num.mrk</code>文件实际上就是管理这层一对多,多对一关系以及维护存储上offset索引的数据结构. (具体的对应关系不展开了, 看图理解)</p>
<p>Clickhouse为什么不直接按照8192行的方式存储数据呢, 我个人的理解是为了最终数据块过大过小影响读取的稳定性. 当数据过小时, 多次查询索引和读数据, 会引起过多的IO. 当数据过大时, 会挤占过多的内存空间影响系统的稳定性.</p>
<p><strong>总结一下</strong></p>
<p>Clickhouse索引的特点为: <code>排序索引</code>+<code>稀疏索引</code> + <code>列式存储</code>,  因此相应的Clickhouse最合适的场景就是<strong>基于排序字段的范围过滤后的聚合查询</strong>.</p>
<ul>
<li>因为<strong>排序索引</strong>,  所有基于<strong>排序字段的查询</strong>会明显由于MR类型计算, 否则Hive/Spark这类动态资源的更优</li>
<li>由于<strong>稀疏索引</strong>, 点查询的效率可能没有KV型数据库高, 因此适合相对大范围的过滤条件</li>
<li>因为<strong>列式存储</strong>,  数据压缩率高, 对应做聚合查询效率也会更高.</li>
</ul>
<p><strong>与Hadoop列存结构的相比</strong></p>
<p>以Parquet的为例, Parquet也会按照行列方式切分整个矩阵, 用<code>Page</code>或者<code>RowGroup</code>的概念实现, 这点跟Clickhouse一样</p>
<p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/FileLayout.gif" alt="File Layout"></p>
<p>Parquet也有部分索引元数据, 能够实现<code>谓词下推(Predicate PushDown)</code>的能力, 因为元数据中包含整个块中的最大最小值, 因此能够方便的过滤数据块. 但是这个索引更像是CK中的<code>跳数索引</code></p>
<p>但是由于Parquet是一个通用的存储格式, 因此它不能像Clickhouse一样定义排序字段, 因此也无法享受折半查找带来的查询优势. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/12/C-%E7%94%A8%E6%B3%95%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/12/C-%E7%94%A8%E6%B3%95%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">C++用法记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-12 18:08:43" itemprop="dateCreated datePublished" datetime="2021-08-12T18:08:43+08:00">2021-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="无名的命名空间"><a href="#无名的命名空间" class="headerlink" title="无名的命名空间"></a>无名的命名空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于命名空间没有名字，在其他文件中显然无法引用，它只在本文件的作用域有效。</p>
<p>若无名命名空间的成员fun函数的作用域为文件A，在文件A中使用无名命名空间的成员，不用也无法用命名空间名限定。</p>
<h2 id="模板里面使用具体的类型"><a href="#模板里面使用具体的类型" class="headerlink" title="模板里面使用具体的类型"></a>模板里面使用具体的类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NeedChild</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Condition = <span class="built_in">bool</span> (*)(<span class="type">const</span> ASTPtr &amp; node, <span class="type">const</span> ASTPtr &amp; child);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">all</span><span class="params">(<span class="type">const</span> ASTPtr &amp;, <span class="type">const</span> ASTPtr &amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">none</span><span class="params">(<span class="type">const</span> ASTPtr &amp;, <span class="type">const</span> ASTPtr &amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Simple matcher for one node type. Use need_child function for complex traversal logic.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Data_, NeedChild::Condition need_child = NeedChild::all, <span class="keyword">typename</span> T = ASTPtr&gt;</span><br><span class="line"><span class="keyword">class</span> OneTypeMatcher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Data = Data_;</span><br><span class="line">    <span class="keyword">using</span> TypeToVisit = <span class="keyword">typename</span> Data::TypeToVisit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">needChildVisit</span><span class="params">(<span class="type">const</span> ASTPtr &amp; node, <span class="type">const</span> ASTPtr &amp; child)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">need_child</span>(node, child); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">visit</span><span class="params">(T &amp; ast, Data &amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> * t = <span class="built_in">typeid_cast</span>&lt;TypeToVisit *&gt;(ast.<span class="built_in">get</span>()))</span><br><span class="line">            data.<span class="built_in">visit</span>(*t, ast);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NeedChild</code>这种用法, 目前不知道具体的称谓.</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>基本格式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [捕获参数](函数参数)&#123;函数体&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fun = []()&#123; std::cout &lt;&lt; <span class="string">&quot;Hello Lambda&quot;</span> &lt;&lt; std::endl; &#125;;</span><br></pre></td></tr></table></figure>
<p>捕获列表:</p>
<ul>
<li><code>[]</code>: 没有使用任何函数对象参数</li>
<li><code>[=]</code>: 函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）</li>
<li><code>[&amp;]</code>:  函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）</li>
<li><code>[this]</code>: 函数体内可以使用Lambda所在类中的成员变量</li>
<li><code>[a]</code>: 将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符</li>
<li><code>[&amp;a]</code>: 将a按引用进行传递</li>
<li><code>[a, &amp;b]</code>: 将a按值进行传递，b按引用进行传递</li>
<li><code>[=，&amp;a, &amp;b]</code>: 除a和b按引用进行传递外，其他参数都按值进行传递</li>
<li><code>[&amp;, a, b]</code>: 除a和b按值进行传递外，其他参数都按引用进行传递</li>
</ul>
<blockquote>
<p> Lambda是const函数, 内联展开, 没有实际地址</p>
</blockquote>
<h2 id="的用法"><a href="#的用法" class="headerlink" title="::*的用法"></a>::*的用法</h2><p>Clickhouse有这么的一个结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Optimization</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Function = <span class="built_in">size_t</span> (*)(QueryPlan::Node *, QueryPlan::Nodes &amp;);</span><br><span class="line">    <span class="type">const</span> Function apply = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> QueryPlanOptimizationSettings::* <span class="type">const</span> is_enabled&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>is_enabled</code> is a pointer to a member. It means that it points to an <code>bool</code> member variable that is declared in the class <code>QueryPlanOptimizationSettings</code>.</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/9939305/what-is-in-c">参考</a></p>
</blockquote>
<h2 id="类型关键字"><a href="#类型关键字" class="headerlink" title="类型关键字"></a>类型关键字</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto：自动类型推导,声明变量时必须赋初值。类型由右值的决定</span><br><span class="line">decltype :声明表达式类型，声明变量时时不必赋初值。类型由编译器根据表达式自动推导</span><br><span class="line">typeid：运行时类型信息（RTTi），不能用来声明变量</span><br></pre></td></tr></table></figure>
<p>用法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> b = a;</span><br><span class="line"><span class="keyword">decltype</span>(b) c;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(b))</span><br><span class="line">	&amp;&amp; (<span class="built_in">typeid</span>(a) == <span class="built_in">typeid</span>(c))</span><br><span class="line">	&amp;&amp; (<span class="built_in">typeid</span>(b) == <span class="built_in">typeid</span>(c))) &#123; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强制类型转化"><a href="#强制类型转化" class="headerlink" title="强制类型转化"></a>强制类型转化</h2><p>四种类型转化关键字</p>
<ol>
<li><p>static_cast:</p>
<p>任何编写程序时能够明确的类型转换都可以使用static_cast,由于不提供运行时的检查,需要在编写程序时确认转换的安全性。</p>
</li>
<li><p>dynamic_cast</p>
<p>dynamic_cast会在运行时检查类型转换是否合法，具有一定的安全性;上行转换和static_cast没有区别，都是安全的；下行转换时，dynamic_cast会检查转换的类型，相比static_cast更安全</p>
</li>
<li><p>const_cast</p>
<p>常量指针被转换成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引，并且仍然引用原来的对象。</p>
</li>
<li><p>reinterpret_cast<br> 非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。</p>
</li>
</ol>
<p>智能指针无法使用上面的关键字, 有专门的用法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static_pointer_cast</span><br><span class="line">dynamic_pointer_cast</span><br><span class="line">const_pointer_cast </span><br></pre></td></tr></table></figure>
<h2 id="模板的显示实例化"><a href="#模板的显示实例化" class="headerlink" title="模板的显示实例化"></a>模板的显示实例化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T temp;</span><br><span class="line">  temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp; b);  </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/21/Clickhouse%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-Projection%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Carlmartin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Carlmartin' Blog">
      <meta itemprop="description" content="A place for codeing break.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Carlmartin' Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/21/Clickhouse%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB-Projection%E8%B0%83%E7%A0%94/" class="post-title-link" itemprop="url">Clickhouse技术分享: Projection调研</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-21 15:32:53" itemprop="dateCreated datePublished" datetime="2021-07-21T15:32:53+08:00">2021-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-06 16:19:03" itemprop="dateModified" datetime="2024-03-06T16:19:03+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/" itemprop="url" rel="index"><span itemprop="name">技术文章</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Clickhouse的查询性能是有目共睹的优秀, 但与之对应单个查询对于机器资源的消耗也是非常巨大的, 导致Clickhouse整体的QPS会比较低.</p>
<p>当用户需要提高QPS时, 往往会通过建立物化视图, 进预计算, 查询时直接走物化视图来进行加速.</p>
<p>但这种方案有两个缺点:</p>
<ol>
<li>实际上有多张表, 明细查询可能需要走底表, 聚合查询需要查物化视图, 用户管理起来会有一定麻烦程度</li>
<li>如果出现慢查询, 需要用户新建一张物化视图, 然后导入数据, 再通过上线变更的方式, 来规避, 整体流程过长</li>
</ol>
<p>针对以上问题, 业界的预聚合引擎, 类似麒麟都实现了SQL rewrite的功能, 来自动替换用户的查询SQL, 这样上面的问题就直接解决了.</p>
<p>Clickhouse并没有打算基于物化视图的SQL rewrite, 而是实现一个Projection的功能, 号称是DataPart-Level的物化视图</p>
<blockquote>
<p>Originated from Vertica</p>
<ul>
<li>Projections are collections of table columns,</li>
<li>Projections store data in a format that optimizes query execution</li>
</ul>
</blockquote>
<p>看一下这两个的对比, 这里的<code>Query Routing</code>就是我们需要的能力</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Feature</strong></th>
<th style="text-align:center"><strong>Materialized View</strong></th>
<th style="text-align:center"><strong>Projection</strong></th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Data Consistency</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">物化视图需要Merge后保持一致</td>
</tr>
<tr>
<td style="text-align:center">Schema Consistency</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Query Routing</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">就是SQL Rewrite</td>
</tr>
<tr>
<td style="text-align:center">Query Index Optimization</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Partial Materialization</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">Yes (but not recommended)</td>
<td style="text-align:center">这个没必要</td>
</tr>
<tr>
<td style="text-align:center">Complex Queries</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">No (May support ARRAY JOIN)</td>
<td style="text-align:center">Joins或者子查询</td>
</tr>
<tr>
<td style="text-align:center">Special Engines</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">Projection不依赖引擎</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>物化视图在复杂查询上还是有比较大的优势的, 而Clickhouse对于复杂查询的支持很差, 因此Projection的能力已经满足Clickhouse的要求.</p>
</blockquote>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="建表时指定projection"><a href="#建表时指定projection" class="headerlink" title="建表时指定projection"></a>建表时指定projection</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">       name1 [type1] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr1] [compression_codec] [TTL expr1],</span><br><span class="line">       ...</span><br><span class="line">       PROJECTION projection_name_1 (<span class="keyword">SELECT</span> <span class="operator">&lt;</span><span class="keyword">COLUMN</span> LIST EXPR<span class="operator">&gt;</span> [<span class="keyword">GROUP</span> <span class="keyword">BY</span>] [<span class="keyword">ORDER</span> <span class="keyword">BY</span>]),</span><br><span class="line">       ...</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br></pre></td></tr></table></figure>
<p>其中<code>projection_name_1</code>就是Projection的名字, 目前语法只支持<code>GROUP BY</code>和<code>ORDER BY</code>, 且两者不能同时出现.</p>
<blockquote>
<p>不支持Join等其他更加复杂的表达式</p>
</blockquote>
<p>如果是<code>GROUP BY</code>的话, 底层存储会使用<code>AggregatedMergeTree</code></p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p><img src="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/img/image-20210727112308287.png" alt="image-20210727112308287"></p>
<p>当创建一个物化视图的时候, 会在DataPart的目录下, 生成以ProjectionName命名的文件夹, 文件夹里面存储着Projection的数据</p>
<p>如上图的<code>tp1.proj</code>目录</p>
<h3 id="DDL语法"><a href="#DDL语法" class="headerlink" title="DDL语法"></a>DDL语法</h3><h4 id="添加Projection"><a href="#添加Projection" class="headerlink" title="添加Projection"></a>添加Projection</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">table</span> <span class="keyword">ADD</span> PROJECTION name <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">&lt;</span><span class="keyword">COLUMN</span> LIST EXPR<span class="operator">&gt;</span>  [<span class="keyword">GROUP</span> <span class="keyword">BY</span>] [<span class="keyword">ORDER</span> <span class="keyword">BY</span>];</span><br></pre></td></tr></table></figure>
<h4 id="删除Projection"><a href="#删除Projection" class="headerlink" title="删除Projection"></a>删除Projection</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">table</span> <span class="keyword">DROP</span> PROJECTION name;</span><br></pre></td></tr></table></figure>
<h4 id="物化Projection"><a href="#物化Projection" class="headerlink" title="物化Projection"></a>物化Projection</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">table</span> MATERIALIZE PROJECTION name [<span class="keyword">IN</span> <span class="keyword">PARTITION</span> partition_name];</span><br></pre></td></tr></table></figure>
<h4 id="删除Projection数据"><a href="#删除Projection数据" class="headerlink" title="删除Projection数据"></a>删除Projection数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">table</span> CLEAR PROJECTION name [<span class="keyword">IN</span> <span class="keyword">PARTITION</span> partition_name];</span><br></pre></td></tr></table></figure>
<h3 id="语句查询"><a href="#语句查询" class="headerlink" title="语句查询"></a>语句查询</h3><p>目前Projection依然是实验特性, 默认是关闭的, 需要通过配置项开启</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> allow_experimental_projection_optimization<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要判断是否命中Projection, 那么可以设置以下配置, 如果没有使用Projection, 那么程序会直接抛出异常</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> force_optimize_projection<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>后续就能正常使用Select语句进行查询</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="预聚合"><a href="#预聚合" class="headerlink" title="预聚合"></a>预聚合</h4><p>创建一张基表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> default.part_local</span><br><span class="line">(</span><br><span class="line">    `P_PARTKEY` UInt32,</span><br><span class="line">    `P_NAME` String,</span><br><span class="line">    `P_MFGR` LowCardinality(String),</span><br><span class="line">    `P_CATEGORY` LowCardinality(String),</span><br><span class="line">    `P_BRAND` LowCardinality(String),</span><br><span class="line">    `P_COLOR` LowCardinality(String),</span><br><span class="line">    `P_TYPE` LowCardinality(String),</span><br><span class="line">    `P_SIZE` UInt8,</span><br><span class="line">    `P_CONTAINER` LowCardinality(String)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> P_PARTKEY;</span><br></pre></td></tr></table></figure>
<p>创建Projection</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除历史Projection</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> default.part_local <span class="keyword">drop</span> projection tp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建Projection</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> default.part_local</span><br><span class="line">    <span class="keyword">ADD</span> PROJECTION tp</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            P_BRAND,</span><br><span class="line">            P_CATEGORY,</span><br><span class="line">            <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c,</span><br><span class="line">            xxHash32(<span class="built_in">sum</span>(P_SIZE)) <span class="keyword">AS</span> s</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            P_BRAND,</span><br><span class="line">            P_CATEGORY</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 物化历史数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">TABLE</span> default.part_local MATERIALIZE PROJECTION tp;</span><br></pre></td></tr></table></figure>
<p>查询使用Projection</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    P_CATEGORY,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c,</span><br><span class="line">    <span class="built_in">sqrt</span>(<span class="built_in">sum</span>(P_SIZE)) <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">FROM</span> default.part_local</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> P_CATEGORY</span><br></pre></td></tr></table></figure>
<p>当查询的依赖的列都在Projection时, 就会触发SQL Rewrite.</p>
<blockquote>
<p>另外一个值得注意的是, 对于这个列<code>xxHash32(sum(P_SIZE)) AS s</code>, Projection实际储的是<code>sum(P_SIZE)</code>, 而非<code>xxHash32(sum(P_SIZE))</code></p>
<p>因此在这个查询的Case中, 能够命中<code>sqrt(sum(P_SIZE))</code>查询语法. 如果查询<code>max(P_SIZE)</code>, 则无法命中Projection</p>
</blockquote>
<h4 id="排序键替换"><a href="#排序键替换" class="headerlink" title="排序键替换"></a>排序键替换</h4><p>另外一个常见的场景, 就是用户需要查询两类的索引, 而CK的主键索引类似组合索引, 遵循最左匹配原则.</p>
<p>举个例子, 有个表如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> default.part_local</span><br><span class="line">(</span><br><span class="line">    `P_PARTKEY` UInt32,</span><br><span class="line">    `P_NAME` String,</span><br><span class="line">    `P_MFGR` LowCardinality(String),</span><br><span class="line">    `P_CATEGORY` LowCardinality(String),</span><br><span class="line">    `P_BRAND` LowCardinality(String),</span><br><span class="line">    `P_COLOR` LowCardinality(String),</span><br><span class="line">    `P_TYPE` LowCardinality(String),</span><br><span class="line">    `P_SIZE` UInt8,</span><br><span class="line">    `P_CONTAINER` LowCardinality(String)</span><br><span class="line">)</span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> P_PARTKEY;</span><br></pre></td></tr></table></figure>
<p>有两类常用的查询SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.part_local <span class="keyword">where</span> P_PARTKEY <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.part_local <span class="keyword">where</span> P_BRAND <span class="operator">=</span> <span class="string">&#x27;XX&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这时排序键只能满足<code>P_PARTKEY</code>的查询, 即使将排序键设置为<code>(P_PARTKEY,P_BRAND )</code> , 查询<code>where P_BRAND = &#39;XX&#39;</code>也无法命中索引.</p>
<p>先前的处理方式, 就只能建一个额外的物化视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span>  part_mv1 </span><br><span class="line">ENGINE <span class="operator">=</span> MergeTree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> P_BRAND</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> default.part_local;</span><br></pre></td></tr></table></figure>
<p>查询<code>P_BRAND</code>需要指定物化视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.part_mv1 <span class="keyword">where</span> P_BRAND <span class="operator">=</span> <span class="string">&#x27;XX&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Clickhouse实际上有二级索引的能力, 但是由于本身主键索引已经稀疏索引了, 二级索引实现为跳数索引, 匹配率就更加差了, 因此在高QPS情况下, 效果非常差</p>
<p>线上只有在低QPS场景, 才允许业务使用</p>
</blockquote>
<p>有了Projection后, 使用建一个Projection来解决</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> default.part_local <span class="keyword">drop</span> projection tp1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> default.part_local</span><br><span class="line">    <span class="keyword">ADD</span> PROJECTION tp1</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            P_PARTKEY,</span><br><span class="line">            P_NAME,</span><br><span class="line">            P_MFGR,</span><br><span class="line">            P_CATEGORY,</span><br><span class="line">            P_BRAND,</span><br><span class="line">            P_COLOR,</span><br><span class="line">            P_TYPE,</span><br><span class="line">            P_SIZE,</span><br><span class="line">            P_CONTAINER</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> P_BRAND</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">TABLE</span> default.part_local MATERIALIZE PROJECTION tp1;</span><br></pre></td></tr></table></figure>
<p>然后查询<code>P_BRAND</code>就能命中主键索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> default.part_mv1 <span class="keyword">where</span> P_BRAND <span class="operator">=</span> <span class="string">&#x27;XX&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个版本的一个比较大的问题, 一旦开启Projection后,  按照<code>P_PARTKEY</code>查询依然会走Projection, 然后实际上查询原始表的效果最好</p>
</blockquote>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h2 id="附录-资料地址"><a href="#附录-资料地址" class="headerlink" title="附录: 资料地址"></a>附录: 资料地址</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>链接地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计文档</td>
<td><a href="https://github.com/ClickHouse/ClickHouse/issues/14730">ISSUE地址</a></td>
</tr>
<tr>
<td>PullRequest</td>
<td><a href="https://github.com/ClickHouse/ClickHouse/pull/20202">PR地址</a></td>
</tr>
<tr>
<td>Meetup分享PPT</td>
<td><a href="https://carlmartin-pic-1305764798.cos.ap-chengdu.myqcloud.com/doc/3.%20clickhouse%20meetup%202021-02-06%20%E9%83%91%E5%A4%A9%E7%A5%BA.pdf">链接地址</a></td>
</tr>
<tr>
<td>Meetup分享视频</td>
<td><a href="https://www.bilibili.com/video/BV1eo4y197wm">观看地址</a></td>
</tr>
<tr>
<td>物化视图Rewrite</td>
<td><a href="https://calcite.apache.org/docs/materialized_views.html">Calcite官网文档</a></td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Carlmartin</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">186k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:49</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
